
//============= Define Global Entities ==============//
file fid;

//============= Main Functions ==============//
void main()
{
    Print( string("Begin Master VSP V&V Script\n") );

    const string html_fname = GetVSPVersion() + string("_VV.html");
    
    // Open the file in 'write' mode and check for success
    if( fid.open(html_fname, "w") < 0 ) 
    {
      string message =  string("Error: Failed to Open ") + html_fname + string("\n");
      Print( message );
      return;
    }
    
    HTML html = HTML(); // Initialize HTML class

    html.WriteHTMLHeader();
    
    TestAll( html );
    
    html.AddResizeEvent();
    html.WriteHTMLBody();

    fid.writeString( string("</html>") );
    fid.close();
    
    //==== Check For API Errors ====//
    while ( GetNumTotalErrors() > 0 )
    {
        ErrorObj err = PopLastError();
        Print( err.GetErrorString() );
    }
    
    Print( string( "End Master VSP V&V Script\n" ) );
}

void TestAll(HTML @ html)
{
    // Set the flags here for which studies to run
    const bool HersheyFlag = true;
    const bool SweptFlag = true;
    const bool BertinFlag = true;
    const bool WarrenFlag = true;
    const bool VKTFlag = true;
    const bool EllipseFlag = true;
    const bool SuperDeltaFlag = true;
    
    if ( HersheyFlag )
    {
        html.m_hvv = HersheyVV(); // Initialize HersheyVV class

        //====Execute Hershey Bar AR Tess Study====//
        html.m_hvv.HersheyBarARTessStudy();
    }
    
    if ( SweptFlag )
    {
        html.m_svv = SweepVV(); // Initialize SweepVV class
        
        //====Execute Swept Wing AR Tess Study====//
        html.m_svv.SweepARTessStudy();
        
        //====Execute Swept Wing Sweep Study====//
        html.m_svv.SweepSweepStudy();
    }
    
    if ( BertinFlag )
    {
        html.m_bvv = BertinVV(); // Initialize BertinVV class
        
        //====Execute Bertin-Smith Study====//
        html.m_bvv.BertinSmithStudy();
    }
    
    if ( WarrenFlag )
    {
        html.m_wvv = WarrenVV(); // Initialize WarrenVV class
        
        //====Execute Warren-12 Study====//
        html.m_wvv.WarrrenStudy();
    }
    
    if ( VKTFlag )
    {
        html.m_vktvv = VKTVV(); // Initialize VKTVV class
        
        //====Execute VKT Epsilon Kappa Tau Tess Study====//
        html.m_vktvv.VKTStudy();
    }
    
    if ( EllipseFlag )
    {
        html.m_evv = EllipsoidVV(); // Initialize EllipsoidVV class
        
        //====Execute Ellipsoid Study====//
        html.m_evv.EllipsoidStudy();
    }
    
    if ( SuperDeltaFlag )
    {
        html.m_sdvv = SDVV(); // Initialize SDVV class
        
        //====Execute Supersonic Delta Wing Study====//
        html.m_sdvv.TestSupersonicDeltaWing();
    }
}

//============= Helper Functions ==============//
array<vec3d> ReadCpDistFile( string file_name )
{
    // This function reads in an XFoil CpDistribution file and returns an array<vec3d>
    //  in the format (x,y,Cp)
    array<vec3d> x_y_cp_vec;
    file@ cp_file = file();

    if( cp_file.open(file_name, "r") < 0 )
    {
      string message =  string("Error: Failed to Open ") + file_name + string("\n");
      Print( message );
      return x_y_cp_vec;
    }

    uint row_cnt = 0;
    
    while ( !cp_file.isEndOfFile() )
    {
        const string line = cp_file.readLine();
        row_cnt++;
        
        if ( row_cnt > 3 )
        {
            array<string> line_array = line.split(" ");
            
            vec3d x_y_cp;
            uint index = 0;
            
            for ( uint i = 0; i < uint(line_array.length()); i++ )
            {
                if ( ( line_array[i].length() > 1 ) && index < 3 )
                {
                    x_y_cp[index] = parseFloat(line_array[i]);
                    index++;
                }
            }
            
            x_y_cp_vec.push_back(x_y_cp);
        }
    }

    cp_file.close();
    
    return x_y_cp_vec;
}

//============= HTML Support Functions ==============//
class HTML
{
    HTML()
    {
    }
    
    void WriteHTMLHeader()
    {
        fid.writeString( string("<!DOCTYPE html>\n") );
        fid.writeString( string("<html lang='en'>\n") );
        
        fid.writeString( string("  <head>\n") );
        fid.writeString( string("\t<title>OpenVSP Verification and Validation</title>\n") );
        fid.writeString( string("\t<meta charset='utf-8'>\n") );
        fid.writeString( string("\t<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n") );
        
        // CSS 
        fid.writeString( string("\t<style>\n") );
        fid.writeString( string("\t  * { box-sizing: border-box; }\n") );
        fid.writeString( string("\t  body { margin: 0; counter-reset: section; }\n") );
        fid.writeString( string("\t  .column.content p { font-size: 110%; }\n") );
        fid.writeString( string("\t  h1 { text-align: center; counter-reset: subsection; }\n") );
        fid.writeString( string("\t  h1::before { counter-increment: section; content: 'Case ' counter(section) ': ';}\n") );
        fid.writeString( string("\t  .topnav { overflow: hidden; background-color: #333; }\n") );
        fid.writeString( string("\t  .topnav a { float: left; display: block; color: #f2f2f2; text-align: center; padding: 14px 16px; text-decoration: none; }\n") );
        fid.writeString( string("\t  .topnav a:hover { background-color: #ddd; color: black; }\n") );
        fid.writeString( string("\t  .chartl { float: left; margin-left: 0.5vmin; margin-right: 0.5vmin; }\n") );
        fid.writeString( string("\t  .chartr { float: right; margin-left: 0.5vmin; margin-right: 0.5vmin; }\n") );
        fid.writeString( string("\t  .chartc { display: table; margin: 0 auto }\n") );
        fid.writeString( string("\t  .column { float: left; }\n") );
        fid.writeString( string("\t  .column.toc { width: 10%; position: sticky; position: -webkit-sticky; top: 0; padding-left: 5px; padding-right: 5px; padding-top: 5px; }\n") );
        fid.writeString( string("\t  .toc_title { font-size: 2.6vmin; font-weight: 800; text-align: center; }\n") );
        fid.writeString( string("\t  #toc_container { background: #f9f9f9; border: 2px solid #aaa; padding: 0.6vmin; width: 98%; word-wrap: break-word; }\n") );
        fid.writeString( string("\t  ul { list-style-position: outside; padding-left: 2vmin; font-size: 1.8vmin; }\n") );
        fid.writeString( string("\t  ul ul { padding-left: 1.35vmin; font-size: 1.5vmin; }\n") );
        fid.writeString( string("\t  li { margin: 5px 0; }\n") );
        fid.writeString( string("\t  table.center { margin: auto; border-collapse: collapse; } \n") );
        fid.writeString( string("\t  table.center.vspaero { width: 42.5%; } \n") );
        fid.writeString( string("\t  table.center.setup { width: 60%; } \n") );
        fid.writeString( string("\t  caption { text-align: center; font-weight: bold; font-size: 115%; } \n") );
        fid.writeString( string("\t  th, td { padding: 8px; border: 1px solid black; } \n") );
        fid.writeString( string("\t  th { text-align: left; background-color: #333; color: white; } \n") );
        fid.writeString( string("\t  tr:nth-child(even){background-color: #f2f2f2;} \n") );
        fid.writeString( string("\t  .column.content { counter-reset: section; width: 90%; background-color: #ddd; padding: 10px 25px 15px 25px }\n") );
        fid.writeString( string("\t  .clearfix { clear: both; }\n") );
        fid.writeString( string("\t  .row:after, .row:before { clear: both; display: table; content: ' '; }\n") );
        fid.writeString( string("\t  .footer { overflow: auto; text-align: center; font-size: 115%; background-color: #f1f1f1; padding: 10px; }\n") );
        fid.writeString( string("\t  @media (max-width: 600 px) { .column.toc, .column.content { width: 100%; } }\n") ); // Remove?
        fid.writeString( string("\t</style>\n") );
        
        // JavaScript
        //fid.writeString( string("\t<script type='text/x-mathjax-config'>MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: 'all' } } });</script>\n") ); // Auto equation #s
        fid.writeString( string("\t<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>\n") ); // MathJax JavaScript
        fid.writeString( string("\t<script src='https://www.gstatic.com/charts/loader.js'></script>\n") ); // Google Charts JavaScript
        fid.writeString( string("\t<script src='https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js'></script>\n") ); // Include jQuery Javascript library
        fid.writeString( string("\t<script >\n") );
        fid.writeString( string("\t  // Load the Visualization API and the chart package.\n") );
        fid.writeString( string("\t  google.charts.load('current', {'packages':['corechart']});\n\n") );
    }
    
    void AddResizeEvent()
    {
        fid.writeString( string("\t  $(window).resize(function() {\n") );
        fid.writeString( string("\t\tif(this.resizeTO) clearTimeout(this.resizeTO);\n") );
        fid.writeString( string("\t\tthis.resizeTO = setTimeout(function() {\n") );
        fid.writeString( string("\t\t  $(this).trigger('resizeEnd');\n") );
        fid.writeString( string("\t\t}, 500);\n") ); // Reduce the time?
        fid.writeString( string("\t  });\n\n") );
        
        fid.writeString( string("\t  $(window).on('resizeEnd', function() {\n") );
        
        for ( uint i = 0; i < uint(m_hvv.m_HersheyARIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_hvv.m_HersheyARIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_hvv.m_HersheyTessIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_hvv.m_HersheyTessIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_hvv.m_HersheyLDIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_hvv.m_HersheyLDIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_hvv.m_HersheyARppIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_hvv.m_HersheyARppIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_svv.m_SweepARIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_svv.m_SweepARIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_svv.m_SweepTessIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_svv.m_SweepTessIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_svv.m_SweepSweepLAvCRIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_svv.m_SweepSweepLAvCRIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_svv.m_SweepSweepClavARIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_svv.m_SweepSweepClavARIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_svv.m_SweepSweepErrorIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_svv.m_SweepSweepErrorIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_bvv.m_AlphaErrorIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_bvv.m_AlphaErrorIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_wvv.m_AlphaErrorIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_wvv.m_AlphaErrorIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_vktvv.m_VKTEpsKapTauIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_vktvv.m_VKTEpsKapTauIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_vktvv.m_VKTTessIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_vktvv.m_VKTTessIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_evv.m_EllispoidIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_evv.m_EllispoidIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        for ( uint i = 0; i < uint(m_sdvv.m_SuperDeltaIDVec.length()); i++ )
        {
            string fun = string("\t\t") + m_sdvv.m_SuperDeltaIDVec[i] + string("();\n");
            fid.writeString( fun );
        }
        
        fid.writeString( string("\t  });\n\n") );
    }
    
    void WriteHTMLBody()
    {
        // End header
        fid.writeString( string("\t</script>\n") ); 
        fid.writeString( string("  </head>\n") );

        fid.writeString( string("  <body>\n") ); // Begin Body
        
        WriteHTMLTopNav();
        WriteHTMLContent();
        WriteHTMLFooter();
        
        fid.writeString( string("  </body>\n") ); // End Body
    }

    private void WriteHTMLTopNav()
    {
        // Header
        fid.writeString( string("\t<div class='topnav'>\n") );
        fid.writeString( string("\t  <a href='http://www.openvsp.org'>OpenVSP Home</a>\n") );
        fid.writeString( string("\t  <a href='http://www.openvsp.org/wiki/doku.php'>OpenVSP Wiki</a>\n") );
        fid.writeString( string("\t  <h2 style='color: white; text-align: center; padding-right: 5vmin; font-size: 120%; font-weight: bold;'>OpenVSP Verification & Validation Studies</h2>\n") );
        fid.writeString( string("\t</div>\n") );
    }

    private void WriteHTMLTOC()
    {
        // Table of Contents
        fid.writeString( string("\t  <div class='column toc'>\n") );
        fid.writeString( string("\t\t<div id='toc_container'>\n") );
        fid.writeString( string("\t\t<h3 class='toc_title'>Contents</h3>\n") );
        fid.writeString( string("\t\t<ul>\n") );
        fid.writeString( string("\t\t  <li><a href='#INT'>Introduction</a></li>\n") );
        fid.writeString( string("\t\t  <li><a href='#NOT'>Notation</a></li>\n") );
        fid.writeString( string("\t\t  <li><a href='#EQU'>Equations</a></li>\n") );
        if ( m_hvv.m_runflag )
        {
            fid.writeString( string("\t\t  <li><a href='#HBW'>Hershey Bar</a>\n") );
            fid.writeString( string("\t\t\t<ul>\n") );
            if ( m_hvv.m_HersheyARIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#HAR'>AR Study</a></li>\n") );
            }
            if ( m_hvv.m_HersheyTessIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#HTess'>Tesselation Study</a></li>\n") );
            }
            if ( m_hvv.m_HersheyLDIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#HLD'>Lift Distribution Study</a></li>\n") );
            }
            if ( m_hvv.m_HersheyARppIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#HARpp'>AR Per Panel Study</a></li>\n") );
            }
            fid.writeString( string("\t\t\t</ul>\n") );
            fid.writeString( string("\t\t  </li>\n") );
        }
        if ( m_svv.m_runflag )
        {
            fid.writeString( string("\t\t  <li><a href='#SW'>Swept Wing</a>\n") );
            fid.writeString( string("\t\t\t<ul>\n") );
            if ( m_svv.m_SweepARIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#SAR'>AR Study</a></li>\n") );
            }
            if ( m_svv.m_SweepTessIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#STess'>Tesselation Study</a></li>\n") );
            }
            if ( m_svv.m_SweepSweepLAvCRIDVec.length() > 0 || m_svv.m_SweepSweepErrorIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#SSS'>Sweep Study</a></li>\n") );
            }
            fid.writeString( string("\t\t\t</ul>\n") );
            fid.writeString( string("\t\t  </li>\n") );
        }
        if ( m_bvv.m_runflag )
        {
            fid.writeString( string("\t\t  <li><a href='#BSW'>Bertin-Smith</a>\n") );
            fid.writeString( string("\t\t  </li>\n") );
        }
        if ( m_wvv.m_runflag )
        {
            fid.writeString( string("\t\t  <li><a href='#WW'>Warren-12</a>\n") );
            fid.writeString( string("\t\t  </li>\n") );
        }
        if ( m_vktvv.m_runflag )
        {
            fid.writeString( string("\t\t  <li><a href='#VKTW'>Von Karman-Trefftz</a>\n") );
            fid.writeString( string("\t\t\t<ul>\n") );
            if ( m_vktvv.m_VKTEpsKapTauIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#VKTE'>Epsilon Kappa Tau Study</a></li>\n") );
            }
            if ( m_vktvv.m_VKTTessIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t\t  <li><a href='#VKTT'>Tesselation Study</a></li>\n") );
            }
            fid.writeString( string("\t\t\t</ul>\n") );
            fid.writeString( string("\t\t  </li>\n") );
        }
        if ( m_evv.m_runflag && m_evv.m_EllispoidIDVec.length() > 0 )
        {
            fid.writeString( string("\t\t  <li><a href='#EW'>Ellipsoid</a>\n") );
            fid.writeString( string("\t\t  </li>\n") );
        }
        if ( m_sdvv.m_runflag )
        {
            fid.writeString( string("\t\t  <li><a href='#SDW'>Supersonic Delta Wing</a>\n") );
            fid.writeString( string("\t\t  </li>\n") );
        }
        
        fid.writeString( string("\t\t  <li><a href='#REF'>References</a>\n") );
        fid.writeString( string("\t\t  </li>\n") );
        
        fid.writeString( string("\t\t</ul>\n") );
        fid.writeString( string("\t\t</div>\n") );
        fid.writeString( string("\t  </div>\n") );
    }

    private void WriteHTMLContent()
    {
        // Content Section
        fid.writeString( string("\t<div class='row'>\n") );

        // Table of Contents
        WriteHTMLTOC();
        
        // Main Content
        fid.writeString( string("\t  <div class='column content'>\n") );
        
        fid.writeString( string( "\t\t<h2 id='INT' style='text-align: center; font-size: 200%; font-weight: bold;'>Introduction</h2>\n" ) );
        fid.writeString( string("\t\t<div>\n") );
        
        string text = string("This document outlines a series of verification and validation (V&V) studies that have been conducted for the VSPAERO computational fluid dynamics (CFD) solver. In each of the V&V test cases listed below, there exists published theoretical or experimental results that can be verified for a particular geometric model. The results from VSPAERO are then able to be validated against the published results to determine the accuracy of the solver. Each test begins by modeling a wing or series of wing geometries through the OpenVSP API. The geometric parameters are listed in a table for each study. If a parameter is not listed in the table the default value can be assumed. Each generated model is saved, and therefore can be opened in OpenVSP to verify the model accurately represents the geometry of the V&V study. Depending on the particular test case, the results needed for validation must then be identified or calculated. Once results for validation are established, VSPAERO is setup and executed through the Analysis Manager. The analysis inputs are listed in a table for each study, with default values used for items not identified in the tables. Following VSPAERO execution, results are obtained throught the Results Manager, compared to the published results, and displayed.");

        WriteParagraph( text );
        fid.writeString( string("\t\t</div>\n") );
        
        fid.writeString( string( "\t\t<h2 id='NOT' style='text-align: center; font-size: 200%; font-weight: bold;'>Notation</h2>\n" ) );
        fid.writeString( string("\t\t<div style='font-weight: bold;'>\n") );
        
        text = string("AR\\(\\equiv\\)\tAspect Ratio");
        WriteParagraph( text );
        
        text = string("\\(\\alpha\\equiv\\)\tAngle of Attack");
        WriteParagraph( text );
        
        text = string("B\\(\\equiv\\)\tMach Parameter");
        WriteParagraph( text );
        
        text = string("b\\(\\equiv\\)\tWing Span");
        WriteParagraph( text );
        
        text = string("\\(\\beta\\equiv\\)\tSideslip Angle");
        WriteParagraph( text );
        
        text = string("\\(C_L\\equiv\\)\tCoefficient of Lift"); // per rad?
        WriteParagraph( text );
        
        text = string("\\(C_{L\\alpha}\\equiv\\)\tLift Curve Slope");
        WriteParagraph( text );
        
        text = string("c\\(\\equiv\\)\tWing Chord");
        WriteParagraph( text );
        
        text = string("\\(\\frac{\\partial \\alpha}{\\partial C_L}\\equiv\\)\tLift Angle");
        WriteParagraph( text );
        
        text = string("K\\(\\equiv\\)\tRatio of \\(C_{L\\alpha}\\) to \\(2\\pi\\)");
        WriteParagraph( text );

        text = string("\\(\\Lambda\\equiv\\)\tSweep");
        WriteParagraph( text );
        
        text = string("\\(\\Lambda_{c/2}\\equiv\\)\tSweep of Half Chord Line");
        WriteParagraph( text );
        
        text = string("M\\(\\equiv\\)\tMach Number");
        WriteParagraph( text );
        
        text = string("m\\(\\equiv\\)\tSubsonic (m < 1) or Supersonic (m > 1) Character of Wing Leading Edge");
        WriteParagraph( text );
        
        fid.writeString( string("\t\t</div>\n") );
        fid.writeString( string( "\t\t<h2 id='EQU' style='text-align: center; font-size: 200%; font-weight: bold;'>Equations</h2>\n" ) );
        fid.writeString( string("\t\t<div>\n") );
        
        text = string("Lifting Line Theory provides the following equations outlined in the NACA TN 3911 <span style='font-style: italic'>A Method for Predicting Lift Increments Due to Flap Deflection at Low Angles of Attack in Incompressible Flow</span> by Lowry and Polhamus:");
        WriteParagraph( text );
        
        fid.writeString( string( "\t\t  <p>$$C_{L\\alpha} = \\frac{2\\pi AR }{2 + \\sqrt{(\\frac{AR^2 B^2}{K^2})(1 + \\frac{tan^2 \\Lambda_{c/2}}{B^2}) + 4}}$$</p>\n" ) );
        
        fid.writeString( string( "\t\t  <p>$$B =\\sqrt{1-M^2}$$</p>\n" ) );
        
        fid.writeString( string( "\t\t  <p>$$K =C_{L\\alpha2D}(\\frac{180}{\\pi})/(2\\pi)$$</p>\n" ) );
        
        text = string("The next group of equations are presented for three-dimensional wings in steady supersonic flow in <span style='font-style: italic'>Aerodynamics of Wings and Bodies</span> by Ashley and Landahl:");
        WriteParagraph( text );
        
        fid.writeString( string( "\t\t  <p>$$m =\\frac{B}{tan(\\Lambda)}$$</p>\n" ) );
        
        fid.writeString( string( "\t\t  <p>$$C_{L\\alpha}tan(\\Lambda) = f(m)$$</p>\n" ) );
        
        fid.writeString( string("\t\t</div>\n") );
        
        if ( m_hvv.m_runflag )
        {
            fid.writeString( string( "\t\t<h1 id='HBW'>Hershey Bar</h1>\n" ) );

            text = string("A series of Hershey Bar wings are modeled for this V&V case. Four studies are then conducted that focus on aspect ratio, tesselation, and lift distribution.");
            
            WriteParagraph( text );
            
            HTMLTable t1 = HTMLTable(); // Initialize Table
            array<string> head_str(9);
            head_str[0] = string("Study");
            head_str[1] = string("Airfoil");
            head_str[2] = string("AR");
            head_str[3] = string("Root Chord");
            head_str[4] = string("Tip Chord");
            head_str[5] = string("\\(\\Lambda\\) (°)");
            head_str[6] = string("U Tess");
            head_str[7] = string("W Tess");
            head_str[8] = string("Tip Clustering");
            t1.m_HeaderStringVec = head_str;
            
            array<array<string>> data_mat(3);
            for ( uint i = 0; i < uint(data_mat.length()); i++ )
            {
                data_mat[i].resize(9);
                data_mat[i][1] = string("NACA0012");
                data_mat[i][2] = string("5 to 50");
                data_mat[i][3] = string("1.0");
                data_mat[i][4] = string("1.0");
                data_mat[i][5] = string("0.0");
            }
            
            data_mat[0][0] = string("Aspect Ratio");
            data_mat[0][6] = string("6");
            data_mat[0][7] = string("33");
            data_mat[0][8] = string("1.0");
            
            data_mat[1][0] = string("Tesselation");
            data_mat[1][6] = string("20 to 80");
            data_mat[1][7] = string("20 to 100");
            data_mat[1][8] = string("1.0");
            
            data_mat[2][0] = string("Lift Distribution");
            data_mat[2][6] = string("20 to 80");
            data_mat[2][7] = string("20 to 100");
            data_mat[2][8] = string("0.1 to 1.0");
            
            t1.m_TableDataMat = data_mat;
            t1.m_Width = 0;
            t1.m_Caption = string("Hershey Bar Geometry Setup");
            
            t1.WriteHTMLTable();
            
            if ( m_hvv.m_HersheyARIDVec.length() == 3 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='HAR'>Aspect Ratio Study</h2>\n") );
                
                text = string("In the first Hershey Bar study, the resulting coefficient of lift (\\(C_L\\)) from VSPAERO's vortex lattice solver is compared to the approximate \\(C_L\\) determined for each angle of attack from Lifting Line Theory (LLT). The first plot listed below displays these results.");
                
                WriteParagraph( text );
                
                text = string("Next, the lift curve slope (\\(C_{L\\alpha}\\)) is calculated for each vortex lattice and panel method VSPAERO result, defined by a particular AR, by subtracting \\(C_L\\) at the max and min angle of attack flow condition case and dividing by the total change in alpha (40°). These values are compared to \\(C_{L\\alpha}\\) determined by Lifting Line Theory at the associated aspect ratios. A 2D lift curve slope of 0.1096622 per degree is assumed, given a theoretical K ratio of 1.0. This plot can be seen in the middle graph below.");

                // For the Hershey Bar wing with AR of 50, the error in \\(C_{L\\alpha}\\) between VSPAERO and the theoreticalresults is found to be ") + double(m_hvv.m_Hershey_AR60_Cl_alpha_Err) + string("%.")
                // An experimental K ratio was determined by assuming a 2D \\(C_{L\\alpha}\\) of 0.107699 for a NACA 0012 from <i>Theory of Air Sections</i>, by Abbott and Doenhoff.
                
                WriteParagraph( text );
                
                text = string("The \\(C_{L\\alpha}\\) results from VSPAERO are then used to calculate the Lift Angle (\\(\\frac{\\partial \\alpha}{\\partial C_L}\\)) at each chord ratio (\\(\\frac{1}{AR}\\)). These values are then compared to the theoretical Lift Angle determined by Lifting Line Theory. Lift angle is simply the inverse of \\(C_{L\\alpha}\\) for an angle of attack of 1.0°, so can therefore be determine for the theoretical \\(C_{L\\alpha}\\) as well. This comparison is displayed in the third plot below.");
                
                // The average error between VSPAERO and theoretical Lift Angle results is calculated to be ") + double(m_hvv.m_Hershey_LA_Err) + string("%.")
                
                WriteParagraph( text );
                
                HTMLTable t2 = HTMLTable(); // Initialize Table
                head_str.resize(7);
                head_str[0] = string("Case #");
                head_str[1] = string("Analysis");
                head_str[2] = string("Method");
                head_str[3] = string("\\(\\alpha\\) (°)");
                head_str[4] = string("\\(\\beta\\) (°)");
                head_str[5] = string("M");
                head_str[6] = string("Wake Iterations");
                t2.m_HeaderStringVec = head_str;
                
                data_mat.resize(2);
                data_mat[0].resize(7);
                data_mat[0][0] = string("1");
                data_mat[0][1] = string("Sweep");
                data_mat[0][2] = string("VLM");
                data_mat[0][3] = string("-20.0 to 20.0, npts: 8");
                data_mat[0][4] = string("0.0");
                data_mat[0][5] = m_hvv.m_MachVec[0];
                data_mat[0][6] = m_hvv.m_WakeIterVec[0];
                
                data_mat[1].resize(7);
                data_mat[1][0] = string("2");
                data_mat[1][1] = string("Single Point");
                data_mat[1][2] = string("Panel");
                data_mat[1][3] = string("1.0");
                data_mat[1][4] = string("0.0");
                data_mat[1][5] = m_hvv.m_MachVec[0];
                data_mat[1][6] = m_hvv.m_WakeIterVec[0];
                
                t2.m_TableDataMat = data_mat;
                t2.m_Width = 1;
                t2.m_Caption = string("Aspect Ratio Study VSPAERO Setup");
                
                t2.WriteHTMLTable();
                
                AddChartsToBody(m_hvv.m_HersheyARIDVec);
            }
            
            if ( m_hvv.m_HersheyTessIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='HTess'>Tesselation Study</h2>\n") );
                
                text = string("The next Hershey Bar study investigates the effects of tesselation on VSPAERO VLM results by varying U and W tesselation for certain AR cases. Two charts are generated for each AR case, and can be seen below. The charts in the left column display the percent error between VSPAERO and theoretical lifting line \\(C_{L\\alpha}\\) results as chord tesselation increases at various span tesselations. The charts in the right column display the same error, but as span tesselation increases at various chord tesselations.");
                
                WriteParagraph( text );
                
                HTMLTable t2 = HTMLTable(); // Initialize Table
                head_str.resize(6);
                head_str[0] = string("Analysis");
                head_str[1] = string("Method");
                head_str[2] = string("\\(\\alpha\\) (°)");
                head_str[3] = string("\\(\\beta\\) (°)");
                head_str[4] = string("M");
                head_str[5] = string("Wake Iterations");
                t2.m_HeaderStringVec = head_str;
                
                data_mat.resize(1);
                data_mat[0].resize(6);
                data_mat[0][0] = string("Single Point");
                data_mat[0][1] = string("VLM");
                data_mat[0][2] = string("1.0");
                data_mat[0][3] = string("0.0");
                data_mat[0][4] = m_hvv.m_MachVec[0];
                data_mat[0][5] = m_hvv.m_WakeIterVec[0];
                
                t2.m_TableDataMat = data_mat;
                t2.m_Width = 1;
                t2.m_Caption = string("Tesselation Study VSPAERO Setup");
                
                t2.WriteHTMLTable();
                
                for ( uint i = 0; i < uint(m_hvv.m_HersheyTessIDVec.length()); i+=2 ) // Two charts per row (same AR), chord tess left and span tess right
                {
                    string chart_str = "\t\t  <figure class='chartl' id='" + m_hvv.m_HersheyTessIDVec[i] + "' style='border: 1px solid #ccc'></figure>\n"; // Left chart
                    fid.writeString( chart_str );
                    chart_str = "\t\t  <figure class='chartr' id='" + m_hvv.m_HersheyTessIDVec[i+1] + "' style='border: 1px solid #ccc'></figure>\n"; // Right chart
                    fid.writeString( chart_str );
                    fid.writeString( string("\t\t  <div class='clearfix'></div>\n") );
                }
                
                fid.writeString( string("\t\t</div>\n") ); // end section
                fid.writeString( string("\t\t<div class='clearfix'></div>\n") );
            }
            
            if ( m_hvv.m_HersheyLDIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='HLD'>Lift Distribution Study</h2>\n") );
                
                text = string("This next study looks at the influence of tip clustering on \\(C_L\\) distribution along the Hershey Bar wing span. A handful of wing geometries of particular aspect ratio are selected for this study, and the tip clustering for each is varied. The \\(C_L\\) distribution across the span is compared to the lifting line theoretical \\(C_L\\) distribution. The plots below display how tip clustering and tesselation effects the error between VSPAERO VLM and LLT.");
                
                WriteParagraph( text );
                
                HTMLTable t2 = HTMLTable(); // Initialize Table
                head_str.resize(6);
                head_str[0] = string("Analysis");
                head_str[1] = string("Method");
                head_str[2] = string("\\(\\alpha\\) (°)");
                head_str[3] = string("\\(\\beta\\) (°)");
                head_str[4] = string("M");
                head_str[5] = string("Wake Iterations");
                t2.m_HeaderStringVec = head_str;
                
                data_mat.resize(1);
                data_mat[0].resize(6);
                data_mat[0][0] = string("Single Point");
                data_mat[0][1] = string("VLM");
                data_mat[0][2] = string("1.0");
                data_mat[0][3] = string("0.0");
                data_mat[0][4] = m_hvv.m_MachVec[0];
                data_mat[0][5] = m_hvv.m_WakeIterVec[0];
                
                t2.m_TableDataMat = data_mat;
                t2.m_Width = 1;
                t2.m_Caption = string("Lift Distribution Study VSPAERO Setup");
                
                t2.WriteHTMLTable();
                
                AddChartsToBody(m_hvv.m_HersheyLDIDVec);
            }
        }
        if ( m_svv.m_runflag )
        {
            fid.writeString( string( "\t\t<h1 id='SW'>Swept Wing</h1>\n" ) );
            
            text = string("Swept Hershey Bar wings with AR ranging from are modeled through the OpenVSP API for this V&V case. The wing sweep is measured from the half-chord line for each generated geometry. Three studies are conducted, with some similarities to the previous Hershey Bar studies. The studies investigate VSPAERO VLM and panel method results generated from variations in aspect ratio, tesselation, and sweep.");

            WriteParagraph( text );
            
            HTMLTable t1 = HTMLTable(); // Initialize Table
            array<string> head_str(9);
            head_str[0] = string("Study");
            head_str[1] = string("Airfoil");
            head_str[2] = string("AR");
            head_str[3] = string("Root Chord");
            head_str[4] = string("Tip Chord");
            head_str[5] = string("\\(\\Lambda\\) (°)");
            head_str[6] = string("U Tess");
            head_str[7] = string("W Tess");
            head_str[8] = string("Tip Clustering");
            t1.m_HeaderStringVec = head_str;
            
            array<array<string>> data_mat(3);
            for ( uint i = 0; i < uint(data_mat.length()); i++ )
            {
                data_mat[i].resize(9);
                data_mat[i][1] = string("NACA0012");
                data_mat[i][2] = string("5 to 50");
                data_mat[i][3] = string("1.0");
                data_mat[i][4] = string("1.0");
                data_mat[i][8] = string("1.0");
            }
            
            data_mat[0][0] = string("Aspect Ratio");
            data_mat[0][5] = string("35.0");
            data_mat[0][6] = string("6");
            data_mat[0][7] = string("33");
            
            data_mat[1][0] = string("Tesselation");
            data_mat[1][5] = string("35.0");
            data_mat[1][6] = string("20 to 80");
            data_mat[1][7] = string("20 to 100");
            
            data_mat[2][0] = string("Sweep");
            data_mat[2][5] = string("10 to 40");
            data_mat[2][6] = string("6");
            data_mat[2][7] = string("33");
            
            t1.m_TableDataMat = data_mat;
            t1.m_Width = 0;
            t1.m_Caption = string("Swept Wing Geometry Setup");
            
            t1.WriteHTMLTable();
            
            HTMLTable t2 = HTMLTable(); // Initialize Table
            head_str.resize(7);
            head_str[0] = string("Case #");
            head_str[1] = string("Analysis");
            head_str[2] = string("Method");
            head_str[3] = string("\\(\\alpha\\) (°)");
            head_str[4] = string("\\(\\beta\\) (°)");
            head_str[5] = string("M");
            head_str[6] = string("Wake Iterations");
            t2.m_HeaderStringVec = head_str;
            
            data_mat.resize(2);
            data_mat[0].resize(7);
            data_mat[0][0] = string("1");
            data_mat[0][1] = string("Single Point");
            data_mat[0][2] = string("VLM");
            data_mat[0][3] = string("1.0");
            data_mat[0][4] = string("0.0");
            data_mat[0][5] = m_hvv.m_MachVec[0];
            data_mat[0][6] = m_hvv.m_WakeIterVec[0];
            
            data_mat[1].resize(7);
            data_mat[1][0] = string("2");
            data_mat[1][1] = string("Single Point");
            data_mat[1][2] = string("Panel");
            data_mat[1][3] = string("1.0");
            data_mat[1][4] = string("0.0");
            data_mat[1][5] = m_hvv.m_MachVec[0];
            data_mat[1][6] = m_hvv.m_WakeIterVec[0];
            
            t2.m_TableDataMat = data_mat;
            t2.m_Width = 1;
            t2.m_Caption = string("Swept Wing VSPAERO Setup");
            
            t2.WriteHTMLTable();
            
            if ( m_svv.m_SweepARIDVec.length() == 1 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='SAR'>Aspect Ratio Study</h2>\n") );
                
                
                text = string("The first swept Hershey Bar wing study focusses on the influence of aspect ratio on Lift Angle results. The Lift Angle is calculated from each VSPAERO result as the inverse of \\(C_{L\\alpha}\\) and compared to the theoretical 3D result for each run case, as seen in the plots below. For the theoretical 3D result, a K ratio of 1.0 is assumed.");

                // The average percent error in lift angle for the 35° sweep wing is found to be ") + double( m_svv.m_35Sweep_LA_Err ) + string("%.");
                // For the approximate result, a 2D lift curve slope of 0.107699 was assumed for a NACA 0012 from <i>Theory of Air Sections</i>
                
                WriteParagraph( text );
                
                AddChartsToBody(m_svv.m_SweepARIDVec);
            }
            
            if ( m_svv.m_SweepTessIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='STess'>Tesselation Study</h2>\n") );
                
                text = string("The next swept wing study investigates how tesselation effects VSPAERO results for certain AR cases. A test matrix of wings is created by varying U and W tesselation. For each wing variation and VSPAERO result, two plots are created. In the left column below, the percent error between VSPAERO and theoretical lifting line \\(C_{L\\alpha}\\) results is presented as chord tesselation increases at various span tesselations. A similar error is displayed in the charts to the right, but as span tesselation increases at various chord tesselations.");

                WriteParagraph( text );
                
                for ( uint i = 0; i < uint(m_svv.m_SweepTessIDVec.length()); i+=2 ) // Two charts per row (same AR), chord tess left and span tess right
                {
                    string chart_str = "\t\t  <figure class='chartl' id='" + m_svv.m_SweepTessIDVec[i] + "' style='border: 1px solid #ccc'></figure>\n"; // Left chart
                    fid.writeString( chart_str );
                    chart_str = "\t\t  <figure class='chartr' id='" + m_svv.m_SweepTessIDVec[i+1] + "' style='border: 1px solid #ccc'></figure>\n"; // Right chart
                    fid.writeString( chart_str );
                    fid.writeString( string("\t\t  <div class='clearfix'></div>\n") );
                }
                
                fid.writeString( string("\t\t</div>\n") ); // end section
                fid.writeString( string("\t\t<div class='clearfix'></div>\n") );
            }
            
            if ( m_svv.m_SweepSweepLAvCRIDVec.length() > 0 && m_svv.m_SweepSweepErrorIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='SSS'>Sweep Study</h2>\n") );
                
                text = string("This next swept Hershey Bar wing test looks to identify if sweep value plays a role in the accuracy between VSPAERO and 3D theoretical results. Sweep is varied to create a matrix of wing geometries. For each unique case, the results from VSPAERO VLM and panel method were used to identify the Lift Angle, along with the associated theoretical result. These values were plotted against the chord ratio in the charts below.");
                
                WriteParagraph( text );
                
                for ( uint i = 0; i < uint(m_svv.m_SweepSweepLAvCRIDVec.length()); i++ ) // Two charts per row (same Sweep), LAvCR left and ClavAR right
                {
                    string chart_str = "\t\t  <figure class='chartl' id='" + m_svv.m_SweepSweepClavARIDVec[i] + "' style='border: 1px solid #ccc'></figure>\n"; // Left chart
                    fid.writeString( chart_str );
                    chart_str = "\t\t  <figure class='chartr' id='" + m_svv.m_SweepSweepLAvCRIDVec[i] + "' style='border: 1px solid #ccc'></figure>\n"; // Right chart
                    fid.writeString( chart_str );
                    fid.writeString( string("\t\t  <div class='clearfix'></div>\n") );
                }
                
                fid.writeString( string("\t\t<div>\n") );
                
                text = string("For each sweep value, the average percent error between VSPAERO and theoretical \\(C_{L\\alpha}\\) was calculated across all AR cases. The plot below identifies how average error changes as wing sweep increases.");
                
                WriteParagraph( text );
                
                AddChartsToBody(m_svv.m_SweepSweepErrorIDVec);
            }
        }
        if ( m_bvv.m_runflag )
        {
            fid.writeString( string( "\t\t<h1 id='BSW'>Bertin-Smith</h1>\n" ) );
            
            text = string("A Bertin-Smith Wing is modeled based off of the planform described in <span style='font-style: italic'>Aerodynamics for Engineers</span>, by Bertin and Smith. The book identifies a theoretical approximation for \\(C_{L\\alpha}\\) on page 202 to be 3.433/rad. Two VSPAERO analyses are then run: an alpha sweep and a single alpha point The resulting \\(C_{L\\alpha}\\) from VSPAERO is then compared to the theoretical value. These results can be seen in the plot and table below.");

            WriteParagraph( text );
            
            HTMLTable t1 = HTMLTable(); // Initialize Table
            array<string> head_str(8);
            head_str[0] = string("Airfoil");
            head_str[1] = string("AR");
            head_str[2] = string("Root Chord");
            head_str[3] = string("Tip Chord");
            head_str[4] = string("\\(\\Lambda\\) (°)");
            head_str[5] = string("U Tess");
            head_str[6] = string("W Tess");
            head_str[7] = string("Tip Clustering");
            t1.m_HeaderStringVec = head_str;
            
            array<array<string>> data_mat(1);
            data_mat[0].resize(8);
            data_mat[0][0] = string("NACA0012");
            data_mat[0][1] = string("5");
            data_mat[0][2] = string("0.2");
            data_mat[0][3] = string("0.2");
            data_mat[0][4] = string("45.0");
            data_mat[0][5] = string("6");
            data_mat[0][6] = string("33");
            data_mat[0][7] = string("1.0");
            t1.m_TableDataMat = data_mat;
            t1.m_Width = 0;
            t1.m_Caption = string("Bertin-Smith Geometry Setup");
            
            t1.WriteHTMLTable();
            
            HTMLTable t2 = HTMLTable(); // Initialize Table
            head_str.resize(7);
            head_str[0] = string("Run Case #");
            head_str[1] = string("Analysis");
            head_str[2] = string("Method");
            head_str[3] = string("\\(\\alpha\\) (°)");
            head_str[4] = string("\\(\\beta\\) (°)");
            head_str[5] = string("M");
            head_str[6] = string("Wake Iterations");
            t2.m_HeaderStringVec = head_str;

            data_mat.resize(2);
            data_mat[0].resize(7);
            data_mat[1].resize(7);
            data_mat[0][0] = string("1");
            data_mat[0][1] = string("Single Point");
            data_mat[0][2] = string("VLM");
            data_mat[0][3] = string("1.0");
            data_mat[0][4] = string("0.0");
            data_mat[0][5] = m_bvv.m_MachVec[0];
            data_mat[0][6] = m_bvv.m_WakeIterVec[0];
            data_mat[1][0] = string("2");
            data_mat[1][1] = string("Sweep");
            data_mat[1][2] = string("VLM");
            data_mat[1][3] = string("-20.0 to 20.0, npts: 8");
            data_mat[1][4] = string("0.0");
            data_mat[1][5] = m_bvv.m_MachVec[0];
            data_mat[1][6] = m_bvv.m_WakeIterVec[0];
            t2.m_TableDataMat = data_mat;
            t2.m_Width = 1;
            t2.m_Caption = string("Bertin-Smith VSPAERO Setup");
            
            t2.WriteHTMLTable();
            
            fid.writeString( string("\t\t<div>\n") );
            
            AddChartsToBody(m_bvv.m_AlphaErrorIDVec);
            
            HTMLTable t3 = HTMLTable(); // Initialize Table
            head_str.resize(4);
            head_str[0] = string("\\(\\alpha\\) (°)");
            head_str[1] = string("\\(C_{L\\alpha}\\) Expected (rad)");
            head_str[2] = string("\\(C_{L\\alpha}\\) Result (rad)");
            head_str[3] = string("% Error");
            t3.m_HeaderStringVec = head_str;

            // Sweep Results
            data_mat.resize(m_bvv.m_AlphaNpts + 1);
            for ( uint i = 0; i < uint(m_bvv.m_AlphaNpts); i++ )
            {
                data_mat[i].resize(4);
                data_mat[i][0] = m_bvv.m_AlphaVec[i];
                data_mat[i][1] = m_bvv.m_Cl_alpha_expected;
                data_mat[i][2] = m_bvv.m_Cl_alpha_res[i];
                data_mat[i][3] = m_bvv.m_Cl_alpha_error[i];
            }
            
            // Single Point Results
            data_mat[m_bvv.m_AlphaNpts].resize(4);
            data_mat[m_bvv.m_AlphaNpts][0] = string("1.0");
            data_mat[m_bvv.m_AlphaNpts][1] = m_bvv.m_Cl_alpha_expected;
            data_mat[m_bvv.m_AlphaNpts][2] = m_bvv.m_Cl_alpha_res_single;
            data_mat[m_bvv.m_AlphaNpts][3] = m_bvv.m_Cl_alpha_error_single;

            t3.m_TableDataMat = data_mat;
            t3.m_Width = 1;
            t3.m_Caption = string("Bertin-Smith Results");
            
            t3.WriteHTMLTable();
        }
        if ( m_wvv.m_runflag )
        {
            fid.writeString( string( "\t\t<h1 id='WW'>Warren-12</h1>\n" ) );
            
            text = string("<span style='font-style: italic'>A New Non-Linear Vortex Lattice Method: Applications to Wing Aerodynamic Optimizations</span> by Oliviu, Andreea, and Ruxandra provides the dimensions for a Warren-12 Wing, a geometry that has been commonly used to verify VLM solvers. Theoretical approximations for \\(C_{L\\alpha}\\) and \\(C_{M\\alpha}\\) are published to be 2.743/rad and -3.10/rad respectively. Also like the Bertin-Smith Study, two VSPAERO analyses are then run: an alpha sweep and a single point analysis. \\(C_{L\\alpha}\\) and \\(C_{M\\alpha}\\) results from VSPAERO are compared to the theoretical results. These results can be seen in the plots and table below.");

            WriteParagraph( text );
            
            HTMLTable t1 = HTMLTable(); // Initialize Table
            array<string> head_str(8);
            head_str[0] = string("Airfoil");
            head_str[1] = string("AR");
            head_str[2] = string("Root Chord");
            head_str[3] = string("Tip Chord");
            head_str[4] = string("\\(\\Lambda\\) (°)");
            head_str[5] = string("U Tess");
            head_str[6] = string("W Tess");
            head_str[7] = string("Tip Clustering");
            t1.m_HeaderStringVec = head_str;
            
            array<array<string>> data_mat(1);
            data_mat[0].resize(8);
            data_mat[0][0] = string("NACA0012");
            data_mat[0][1] = string("\\(2 \\sqrt{2}\\)");
            data_mat[0][2] = string("1.5");
            data_mat[0][3] = string("0.5");
            data_mat[0][4] = string("53.54");
            data_mat[0][5] = string("6");
            data_mat[0][6] = string("33");
            data_mat[0][7] = string("1.0");
            t1.m_TableDataMat = data_mat;
            t1.m_Width = 0;
            t1.m_Caption = string("Warren-12 Geometry Setup");
            
            t1.WriteHTMLTable();
            
            HTMLTable t2 = HTMLTable(); // Initialize Table
            head_str.resize(7);
            head_str[0] = string("Run Case #");
            head_str[1] = string("Analysis");
            head_str[2] = string("Method");
            head_str[3] = string("\\(\\alpha\\) (°)");
            head_str[4] = string("\\(\\beta\\) (°)");
            head_str[5] = string("M");
            head_str[6] = string("Wake Iterations");
            t2.m_HeaderStringVec = head_str;

            data_mat.resize(2);
            data_mat[0].resize(7);
            data_mat[1].resize(7);
            data_mat[0][0] = string("1");
            data_mat[0][1] = string("Single Point");
            data_mat[0][2] = string("VLM");
            data_mat[0][3] = string("1.0");
            data_mat[0][4] = string("0.0");
            data_mat[0][5] = m_wvv.m_MachVec[0];
            data_mat[0][6] = m_wvv.m_WakeIterVec[0];
            data_mat[1][0] = string("2");
            data_mat[1][1] = string("Sweep");
            data_mat[1][2] = string("VLM");
            data_mat[1][3] = string("-20.0 to 20.0, npts: 8");
            data_mat[1][4] = string("0.0");
            data_mat[1][5] = m_wvv.m_MachVec[0];
            data_mat[1][6] = m_wvv.m_WakeIterVec[0];
            t2.m_TableDataMat = data_mat;
            t2.m_Width = 1;
            t2.m_Caption = string("Warren-12 VSPAERO Setup");
            
            t2.WriteHTMLTable();
            
            fid.writeString( string("\t\t<div>\n") );
            
            AddChartsToBody(m_wvv.m_AlphaErrorIDVec);
           
            HTMLTable t3 = HTMLTable(); // Initialize Table
            head_str.resize(7);
            head_str[0] = string("\\(\\alpha\\) (°)");
            head_str[1] = string("\\(C_{L\\alpha}\\) Expected (rad)");
            head_str[2] = string("\\(C_{L\\alpha}\\) Result (rad)");
            head_str[3] = string("\\(C_{L\\alpha}\\) % Error");
            head_str[4] = string("\\(C_{M\\alpha}\\) Expected (rad)");
            head_str[5] = string("\\(C_{M\\alpha}\\) Result (rad)");
            head_str[6] = string("\\(C_{M\\alpha}\\) % Error");
            t3.m_HeaderStringVec = head_str;

            // Sweep Results
            data_mat.resize(m_wvv.m_AlphaNpts + 1);
            for ( uint i = 0; i < uint(m_wvv.m_AlphaNpts); i++ )
            {
                data_mat[i].resize(7);
                data_mat[i][0] = m_wvv.m_AlphaVec[i];
                data_mat[i][1] = m_wvv.m_Cl_alpha_expected;
                data_mat[i][2] = m_wvv.m_Cl_alpha_res[i];
                data_mat[i][3] = m_wvv.m_Cl_alpha_error[i];
                data_mat[i][4] = m_wvv.m_Cm_alpha_expected;
                data_mat[i][5] = m_wvv.m_Cm_alpha_res[i];
                data_mat[i][6] = m_wvv.m_Cm_alpha_error[i];
            }
            
            // Single Point Results
            data_mat[m_wvv.m_AlphaNpts].resize(7);
            data_mat[m_wvv.m_AlphaNpts][0] = string("1.0");
            data_mat[m_wvv.m_AlphaNpts][1] = m_wvv.m_Cl_alpha_expected;
            data_mat[m_wvv.m_AlphaNpts][2] = m_wvv.m_Cl_alpha_res_single;
            data_mat[m_wvv.m_AlphaNpts][3] = m_wvv.m_Cl_alpha_error_single;
            data_mat[m_wvv.m_AlphaNpts][4] = m_wvv.m_Cm_alpha_expected;
            data_mat[m_wvv.m_AlphaNpts][5] = m_wvv.m_Cm_alpha_res_single;
            data_mat[m_wvv.m_AlphaNpts][6] = m_wvv.m_Cm_alpha_error_single;

            t3.m_TableDataMat = data_mat;
            t3.m_Width = 0;
            t3.m_Caption = string("Warren-12 Results");
            
            t3.WriteHTMLTable();
        }
        if ( m_vktvv.m_runflag )
        {
            fid.writeString( string( "\t\t<h1 id='VKTW'>Von Karman-Trefftz</h1>\n" ) );
            
            text = string("A series of Von Karman-Trefftz wing are generated using the Karman-Trefftz airfoil available in OpenVSP. Two studies are then conducted with the first varying the VKT airfoil shape and the second varying tesselation in U and W. Two API functions, vsp::GetVKTAirfoilPnts and vsp::GetVKTAirfoilCpDist, are used to determine the theoretical VKT airfoil \\(C_P\\) distribution. The VSP Slicer is executed to identify the \\(C_P\\) distribution at a specified planar slice in each VSPAERO result.");
            
            WriteParagraph( text );
            
            HTMLTable t1 = HTMLTable(); // Initialize Table
            array<string> head_str(13);
            head_str[0] = string("Study");
            head_str[1] = string("Airfoil");
            head_str[2] = string("\\(\\varepsilon\\)");
            head_str[3] = string("\\(\\kappa\\)");
            head_str[4] = string("\\(\\tau\\) (°)");
            head_str[5] = string("AR");
            head_str[6] = string("Root Chord");
            head_str[7] = string("Tip Chord");
            head_str[8] = string("\\(\\lambda\\) (°)");
            head_str[9] = string("U Tess");
            head_str[10] = string("W Tess");
            head_str[11] = string("LE Clustering");
            head_str[12] = string("TE Clustering");
            t1.m_HeaderStringVec = head_str;
            
            array<array<string>> data_mat(2);
            for ( uint i = 0; i < uint(data_mat.length()); i++ )
            {
                data_mat[i].resize(13);
                data_mat[i][1] = string("VKT");
                data_mat[i][6] = string("1.0");
                data_mat[i][7] = string("1.0");
                data_mat[i][8] = string("0.0");
            }
            
            data_mat[0][0] = string("\\(\\varepsilon\\) \\(\\kappa\\) \\(\\tau\\)");
            data_mat[0][2] = string("0.1, 0.2");
            data_mat[0][3] = string("0.0, 0.1");
            data_mat[0][4] = string("0, 10");
            data_mat[0][5] = string("30");
            data_mat[0][9] = string("30");
            data_mat[0][10] = string("70");
            data_mat[0][11] = string("0.35");
            data_mat[0][12] = string("0.65");
            
            data_mat[1][0] = string("Tesselation");
            data_mat[1][2] = string("0.1");
            data_mat[1][3] = string("0.1");
            data_mat[1][4] = string("10");
            data_mat[1][5] = string("15");
            data_mat[1][9] = string("20 to 80");
            data_mat[1][10] = string("20 to 100");
            data_mat[1][11] = string("0.5");
            data_mat[1][12] = string("1.0");
            
            t1.m_TableDataMat = data_mat;
            t1.m_Width = 0;
            t1.m_Caption = string("VKT Geometry Setup");
            
            t1.WriteHTMLTable();
            
            HTMLTable t2 = HTMLTable(); // Initialize Table
            head_str.resize(6);
            head_str[0] = string("Analysis");
            head_str[1] = string("Method");
            head_str[2] = string("\\(\\alpha\\) (°)");
            head_str[3] = string("\\(\\beta\\) (°)");
            head_str[4] = string("M");
            head_str[5] = string("Wake Iterations");
            t2.m_HeaderStringVec = head_str;
            
            data_mat.resize(1);
            data_mat[0].resize(6);
            data_mat[0][0] = string("Single Point");
            data_mat[0][1] = string("Panel");
            data_mat[0][2] = string("0.0");
            data_mat[0][3] = string("0.0");
            data_mat[0][4] = m_vktvv.m_MachVec[0];
            data_mat[0][5] = m_vktvv.m_WakeIterVec[0];
            
            t2.m_TableDataMat = data_mat;
            t2.m_Width = 1;
            t2.m_Caption = string("VKT VSPAERO Setup");
            
            t2.WriteHTMLTable();
            
            if ( m_vktvv.m_VKTEpsKapTauIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='VKTE'>Epsilon Kappa Tau Study</h2>\n") );

                text = string("In this study, the shape of the Von Karman-Trefftz airfoil is manipulated to create a series of unique VKT wings. Theoretical \\(C_P\\) distributions are determined for each VKT airfoil and compared to the results obtained by executing the CpSlicer analysis at the root of the VKT wing. The theoretical and VSPAERO \\(C_P\\) distributions are plotted for each VKT airfoil variation below. Note that if the VKT airfoil is symmetric, there is no difference in the exact \\(C_P\\) solution for the upper and lower surface. When the airfoil is not symmetric, there is a noticeable difference in the \\(C_P\\) distribution between the upper and lower surfaces.");
                
                WriteParagraph( text );
                
                AddChartsToBody(m_vktvv.m_VKTEpsKapTauIDVec);
            }
            
            if ( m_vktvv.m_VKTTessIDVec.length() > 0 )
            {
                fid.writeString( string("\t\t<div>\n") );
                fid.writeString( string("\t\t  <h2 id='VKTT'>Tesselation Study</h2>\n") );
                
                text = string("The next test looks to determine the influence of chord and span tesselation on VSPAERO results for the VKT wing by varying chord and span tesselation to create a matrix of VKT wings. A CpSlicer analysis is then performed on each VSPAERO result with an XZ slice defined at the wing root. The VSPAERO \\(C_P\\) distribution is then compared to the theoretical \\(C_P\\) distribution for the particular VKT airfoil, as seen in the plots below. In addition, XFoil's \\(C_P\\) solution for the VKT airfoil is plotted. This result is obtained by first writting a Selig airfoil file from the same coordinate points used to generate the theoretical VKT Cp distribution. This file is loaded in XFoil 6.99 and run with the identical flow conditions to VSPAERO. In the plots below, a comparison between VSPAERO, XFoil, and theoretical VKT Cp distribution is presented.");
                
                WriteParagraph( text );
                
                AddChartsToBody(m_vktvv.m_VKTTessIDVec);
            }
        }
        if ( m_evv.m_runflag && m_evv.m_EllispoidIDVec.length() > 0 )
        {
            fid.writeString( string( "\t\t<h1 id='EW'>Ellipsoid</h1>\n" ) );

            fid.writeString( string("\t\t<div>\n") );

            text = string("An ellipsoid geometry is modeled for this V&V case. Four VSPAERO single point analyses are then conducted. To validate the VSPAERO results, the surface  coordinate points for the ellipsoid are first calculated using the API function vsp::GetEllipsoidSurfPnts. The \\(C_P\\) is then calculated at each surface point with the API function vsp::GetEllipsoidCpDist with the freestream velocity set to 100 in the X direction, as is default VSPAERO. The vsp::GetEllipsoidCpDist function is based off the algorithms presented in NACA TN 196 by Max M. Munk. Three plots are generated for each VSPAERO run case per. They display the VSPAERO and theoretical \\(C_P\\) distribution along a major axis of the ellispoid.");
            
            WriteParagraph( text );
            
            HTMLTable t1 = HTMLTable(); // Initialize Table
            array<string> head_str(6);
            head_str[0] = string("A Radius");
            head_str[1] = string("B Radius");
            head_str[2] = string("C Radius");
            head_str[3] = string("Center");
            head_str[4] = string("U Tess");
            head_str[5] = string("W Tess");
            t1.m_HeaderStringVec = head_str;
            
            array<array<string>> data_mat(1);
            data_mat[0].resize(6);
            data_mat[0][0] = string("1.0");
            data_mat[0][1] = string("2.0");
            data_mat[0][2] = string("3.0");
            data_mat[0][3] = string("(0.0, 0.0, 0.0)");
            data_mat[0][4] = string("40");
            data_mat[0][5] = string("41");
            
            t1.m_TableDataMat = data_mat;
            t1.m_Width = 0;
            t1.m_Caption = string("Ellipsoid Geometry Setup");
            
            t1.WriteHTMLTable();
            
            HTMLTable t2 = HTMLTable(); // Initialize Table
            head_str.resize(7);
            head_str[0] = string("Run Case #");
            head_str[1] = string("Analysis");
            head_str[2] = string("Method");
            head_str[3] = string("\\(\\alpha\\) (°)");
            head_str[4] = string("\\(\\beta\\) (°)");
            head_str[5] = string("M");
            head_str[6] = string("Wake Iterations");
            t2.m_HeaderStringVec = head_str;
            
            data_mat.resize(4);
            for ( uint i = 0; i < uint(data_mat.length()); i++ )
            {
                data_mat[i].resize(7);
                data_mat[i][0] = i + 1;
                data_mat[i][1] = string("Single Point");
                data_mat[i][2] = string("Panel");
                data_mat[i][5] = m_vktvv.m_MachVec[0];
                data_mat[i][6] = m_vktvv.m_WakeIterVec[0];
            }

            data_mat[0][3] = string("0.0");
            data_mat[0][4] = string("0.0");

            data_mat[1][3] = string("0.0");
            data_mat[1][4] = string("5.0");

            data_mat[2][3] = string("5.0");
            data_mat[2][4] = string("0.0");

            data_mat[3][3] = string("5.0");
            data_mat[3][4] = string("5.0");
            
            t2.m_TableDataMat = data_mat;
            t2.m_Caption = string("Ellipsoid VSPAERO Setup");
            t2.m_Width = 1;
            t2.WriteHTMLTable();
            
            AddChartsToBody(m_evv.m_EllispoidIDVec);
        }
        if ( m_sdvv.m_runflag )
        {
            fid.writeString( string( "\t\t<h1 id='SDW'>Supersonic Delta Wing</h1>\n" ) );
            
            text = string("This next study is similar to a study presented by Dave Kinney at the 2016 OpenVSP Workshop, which compared VSPAERO results to thh theory of three-dimensional wings in steady supersonic flow outlined in <span style='font-style: italic'>Aerodynamics of Wings and Bodies</span> by Ashley and Landahl. Two delta wings are modeled and analyzed with VSPAERO, and the results are displayed alongside experimental data below.");
            
            WriteParagraph( text );
            
            HTMLTable t1 = HTMLTable(); // Initialize Table
            array<string> head_str(10);
            head_str[0] = string("Case #");
            head_str[1] = string("Airfoil");
            head_str[2] = string("Root Chord");
            head_str[3] = string("\\(\\Lambda\\) Location");
            head_str[4] = string("\\(\\Lambda\\) (°)");
            head_str[5] = string("Section \\(\\Lambda\\) Location");
            head_str[6] = string("Section \\(\\Lambda\\) (°)");
            head_str[7] = string("U Tess");
            head_str[8] = string("W Tess");
            head_str[9] = string("Span");
            t1.m_HeaderStringVec = head_str;
            
            array<array<string>> data_mat(2);
            for ( uint i = 0; i < uint(data_mat.length()); i++ )
            {
                data_mat[i].resize(10);
                data_mat[i][0] = i + 1;
                data_mat[i][1] = string("NACA0012");
                data_mat[i][2] = string("6.0");
                data_mat[i][3] = string("0.0");
                data_mat[i][5] = string("1.0");
                data_mat[i][6] = string("0.0");
                data_mat[i][7] = string("6");
                data_mat[i][8] = string("33");
            }
            
            data_mat[0][4] = m_sdvv.m_Sweep[0];
            data_mat[0][9] = string("20");
            
            data_mat[1][4] = m_sdvv.m_Sweep[1];
            data_mat[1][9] = string("7");
            
            t1.m_Width = 0;
            t1.m_TableDataMat = data_mat;
            t1.m_Caption = string("Supersonic Delta Wing Geometry Setup");
            
            t1.WriteHTMLTable();
            
            HTMLTable t2 = HTMLTable(); // Initialize Table
            head_str.resize(6);
            head_str[0] = string("Analysis");
            head_str[1] = string("Method");
            head_str[2] = string("\\(\\alpha\\) (°)");
            head_str[3] = string("\\(\\beta\\) (°)");
            head_str[4] = string("M");
            head_str[5] = string("Wake Iterations");
            t2.m_HeaderStringVec = head_str;
            
            data_mat.resize(1);
            data_mat[0].resize(6);
            data_mat[0][0] = string("Single Point");
            data_mat[0][1] = string("VLM");
            data_mat[0][2] = string("1.0");
            data_mat[0][3] = string("0.0");
            data_mat[0][4] = string("1.135, 1.366, 1.894, 2.386, 2.861, 3.369, 3.884, 4.404");
            data_mat[0][5] = m_sdvv.m_WakeIterVec[0];
            
            t2.m_Width = 0;
            t2.m_TableDataMat = data_mat;
            t2.m_Caption = string("Supersonic Delta Wing VSPAERO Setup");
            
            t2.WriteHTMLTable();
            
            fid.writeString( string("\t\t<div>\n") );
            
            AddChartsToBody(m_sdvv.m_SuperDeltaIDVec);
        }
        
        // References
        fid.writeString( string( "\t\t<h2 id='REF' style='text-align: center; font-size: 175%; font-weight: bold;'>References</h2>\n" ) );
        fid.writeString( string("\t\t<div>\n") );
        fid.writeString( string("\t\t  <ol>\n") );
        
        fid.writeString( string("\t\t\t<li>Abbott, I. & Doenhoff, A. (1959). <span style='font-style: italic'>Theory of Wing Sections: Including a Summary of Airfoil Data</span>. NY: Dover Publications, Inc.</li>\n") );
        fid.writeString( string("\t\t\t<li>Ashley, H. & Landahl, M. (1965). <span style='font-style: italic'>Aerodynamics of Wings and Bodies</span>. MA: Addison-Wesley Publishing Company, Inc.</li>\n") );
        fid.writeString( string("\t\t\t<li>Bertin, J. J., & Smith, M. L. (1994). <span style='font-style: italic'>Aerodynamics for Engineers</span>(2nd ed.). Englewood Cliffs, NJ: Prentice Hall.</li>\n") );
        fid.writeString( string("\t\t\t<li>Hoerner, S. F., & Borst, H. V. (1985). <span style='font-style: italic'>Fluid-Dynamic Lift: Practical Information on Aerodynamic and Hydrodynamic Lift</span> (2nd ed.). Albuquerque/N.M.: Hoerner.</li>\n") );
        fid.writeString( string("\t\t\t<li>Katz, J. & Plotkin, A. (2001). <span style='font-style: italic'>Low-Speed Aerodynamics</span> (2nd ed.). New York: Cambridge University Press.</li>\n") );
        fid.writeString( string("\t\t\t<li>Kinney, D. (2016, August 24). <span style='font-style: italic'>VSPAERO Verification & Next Steps</span>. Live presentation at NASA Ames Conference Center, Mountain View.</li>\n") );
        fid.writeString( string("\t\t\t<li>Lamb, H. (1932). Hydrodynamics (6th ed.). Cambridge, MA: Cambridge University Press.</li>\n") );
        fid.writeString( string("\t\t\t<li>Lowry, J. & Polhamus, E. (1957). <span style='font-style: italic'>A Method for Predicting Lift Increments Due to Flap Deflection at Low Angles of Attack in Incompressible Flow</span>. Virginia: National Advisory Committee for Aeronautics. <a href='https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19930084818.pdf'>https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19930084818.pdf</a>. doi:19930084818</li>\n") );
        fid.writeString( string("\t\t\t<li>Munk, M. (1924). <span style='font-style: italic'>Remarks on the Pressure Distribution over the Surface of an Ellipsoid, Moving Translationally Through a Perfect Fluid</span>. Washington, DC: National Advisory Committee for Aeronautics. <a href='https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19930080983.pdf'> https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19930080983.pdf</a>. doi:19930080983</li>\n") );
        fid.writeString( string("\t\t\t<li>Oliviu, S. G., Andreea K., & Ruxandra M. B. (2016). <span style='font-style: italic'>A New Non-Linear Vortex Lattice Method: Applications to Wing Aerodynamic Optimizations</span>. Quebec: LARCASE Laboratory of Applied Research in Active Controls, Avionics, and Aeroelasticity. <a href='https://ac.els-cdn.com/S1000936116300954/1-s2.0-S1000936116300954-main.pdf?_tid=ecb8e5ea-d93a-11e7-afba-00000aacb362&acdnat=1512423465_5a88062ebd97b0cac725b33f68055f9d'>https://ac.els-cdn.com/S1000936116300954/1-s2.0-S1000936116300954-main.pdf?_tid=ecb8e5ea-d93a-11e7-afba-00000aacb362&acdnat=1512423465_5a88062ebd97b0cac725b33f68055f9d</a>.</li>\n") ); 
        fid.writeString( string("\t\t  </ol>\n") );
        fid.writeString( string("\t\t</div>\n") );
        
        fid.writeString( string("\t  </div>\n") ); // end row
        fid.writeString( string("\t</div>\n") ); // end column content
    }

    private void WriteHTMLFooter()
    {
        // Footer
        fid.writeString( string("\t<div class='footer'>\n") );
        string footer = "\t  <p>Verification & Validation Studies Performed Using " + GetVSPVersion() + "</p>\n";
        fid.writeString( footer );
        fid.writeString( string("\t</div>\n") );
    }
    
    private void AddChartsToBody( array<string> chart_name_vec )
    {
        for ( uint i = 0; i < uint(chart_name_vec.length()); i++ )
        {
            string chart_str = "\t\t  <p><figure class='chartc' id='" + chart_name_vec[i] + "' style='border: 1px solid #ccc'></figure></p>\n"; // center chart
            fid.writeString( chart_str );
        }
        
        fid.writeString( string("\t\t</div>\n") ); // end section
    }
    
    private void WriteParagraph( string text )
    {
        string paragraph = string("\t\t  <p>") + text + string("</p>\n");
        fid.writeString( paragraph );
    }
    
    // HTML Class Properties
    HersheyVV m_hvv;
    SweepVV m_svv;
    BertinVV m_bvv;
    WarrenVV m_wvv;
    VKTVV m_vktvv;
    EllipsoidVV m_evv;
    SDVV m_sdvv;
}

//============= Chart Class ==============//
class HTMLChart
{
    HTMLChart()
    {
        m_PointSize = 5.0;
        m_LegendPos = string("right");
        m_Height = 0.7;
        m_Width = 0.65;
    }
    
    void WriteChartHead( array<string> data_str_vec )
    {
        if ( data_str_vec.length() == 0 )
        {
            return;
        }

        string callback_name = "\t  google.charts.setOnLoadCallback(" + m_ChartName + ");\n";
        fid.writeString( callback_name );
        string fun_name = "\t  function " + m_ChartName + "() {\n";
        fid.writeString( fun_name );
        fid.writeString( string("\t\tvar data = google.visualization.arrayToDataTable([\n") );
        string legend_name = string("\t\t  [") + m_Legend + string("],\n");
        fid.writeString( legend_name );
        
        // Write data
        for ( uint i = 0; i < uint(data_str_vec.length()); i++ )
        {
            fid.writeString( data_str_vec[i] );
        }
        
        fid.writeString( string("\t\t]);\n\n") );
        string width = string("\t\tvar w_size = ") + double(m_Width) + string(" * window.innerWidth;\n");
        fid.writeString( width );
        string height = string("\t\tvar h_size = ") + double(m_Height) + string(" * window.innerHeight;\n\n");
        fid.writeString( height );
        fid.writeString( string("\t\tvar options = {\n") );
        string title_name = string("\t\t  title: '") + m_Title + string("',\n");
        fid.writeString( title_name );
        string pnt_size = string("\t\t  pointSize: ") + double(m_PointSize) + string(",\n");
        fid.writeString( pnt_size );
        
        if ( m_Series.length() > 0 )
        {
            string series_str = string("\t\t  series: ") + m_Series + string(",\n");
            fid.writeString( series_str );
        }
        
        string haxis_name = string("\t\t  ") + m_HAxisString + string(",\n");
        fid.writeString( haxis_name );
        string vaxis_name = string("\t\t  ") + m_VAxisString + string(",\n");
        fid.writeString( vaxis_name );
        fid.writeString( string("\t\t  width: w_size,\n") );
        fid.writeString( string("\t\t  height: h_size,\n") );
        string legend_str = string("\t\t  legend: { position: '") + m_LegendPos + string("', alignment: 'center' },\n");
        fid.writeString( legend_str );
        fid.writeString( string("\t\t  backgroundColor: '#ffffff'\n") );
        fid.writeString( string("\t\t};\n") );

        string add_name = "\n\t\tvar chart = new google.visualization.LineChart(document.getElementById('" + m_ChartName + "'));\n";
        fid.writeString( add_name );
        fid.writeString( string("\n\t\tchart.draw(data, options);\n") );
        
        fid.writeString( string("\t  }\n\n") );
    }
    
    // HTML Chart Class Properties
    string m_ChartName;
    string m_Legend;
    string m_Title;
    string m_VAxisString;
    string m_HAxisString;
    double m_PointSize;
    string m_LegendPos;
    double m_Height;
    double m_Width;
    string m_Series;
}

//============= Table Class ==============//
class HTMLTable
{
    HTMLTable()
    {
        m_Width = 0; // 0: 60% (geometry setup); 1: 42.5% (VSPAERO setup)
    }
    
    void WriteHTMLTable()
    {
        fid.writeString( string("\t\t<p>\n") );
        
        string class_str = string("class='center");
        
        if ( m_Width == 0 )
        {
            class_str += string(" setup");
        }
        else if ( m_Width == 1 )
        {
            class_str += string(" vspaero");
        }
        
        class_str = string("\t\t  <table ") + class_str + string("'>\n");
        fid.writeString( class_str );
        
        if ( m_Caption.length() > 0 )
        {
            string caption = string("\t\t\t<caption>") + m_Caption + string("</caption>\n");
            fid.writeString( caption );
        }
        
        if ( m_HeaderStringVec.length() > 0 )
        {
            fid.writeString( string("\t\t\t<tr>\n") );
            for ( uint i = 0; i < uint(m_HeaderStringVec.length()); i++ )
            {
                string header = string("\t\t\t  <th>") + m_HeaderStringVec[i] + string("</th>\n");
                fid.writeString( header );
            }
            fid.writeString( string("\t\t \t</tr>\n") );
        }
        
        for ( uint r = 0; r < uint(m_TableDataMat.length()); r++ )
        {
            fid.writeString( string("\t\t\t<tr>\n") );
            for ( uint c = 0; c < uint(m_TableDataMat[r].length()); c++ )
            {
                string data = string("\t\t\t  <td>") + m_TableDataMat[r][c] + string("</td>\n");
                fid.writeString( data );
            }
            fid.writeString( string("\t\t\t</tr>\n") );
        }
        
        fid.writeString( string("\t\t  </table>\n") );
        fid.writeString( string("\t\t</p>\n") );
    }
    
    // HTML Table Class Properties
    string m_Caption;
    int m_Width;
    array<array<string>> m_TableDataMat;
    array<string> m_HeaderStringVec;
}

//============= V&V Base Class ==============//
class VV_Base
{
    VV_Base()
    {
        m_CompGeomAnalysis = string("VSPAEROComputeGeometry");
        m_VSPSingleAnalysis = string("VSPAEROSinglePoint");
        m_VSPSweepAnalysis = string("VSPAEROSweep");
        m_CpSliceAnalysis = string("CpSlicer");
        
        m_MachVec[0] = 0.1;
        m_GeomVec[0] = 0; // Set: All
        m_RefFlagVec[0] = 1; // Wing Reference
        m_WakeIterVec[0] = 3;
        
        pi = 3.14159265358979323846;
        b = 0.9949874371; // M = 0.1, b = (1-M^2)^0.5
        k_theo = 1.0;
        
        m_runflag = false;
    }
    
    // V&V Base Class Properties
    string m_CompGeomAnalysis;
    string m_VSPSingleAnalysis;
    string m_VSPSweepAnalysis;
    string m_CpSliceAnalysis;
    
    array<double> m_MachVec(1);
    array<int> m_GeomVec(1);
    array<int> m_RefFlagVec(1);
    array<int> m_WakeIterVec(1);
    
    double pi;
    double b;
    double k_theo;
    
    bool m_runflag;
}

//============= Hershey Bar AR Tess Study Functions ==============//
class HersheyVV : VV_Base
{
    HersheyVV()
    {
        m_halfAR[0] = 2.5005;
        m_halfAR[1] = 3.505;
        m_halfAR[2] = 5;
        m_halfAR[3] = 10;
        m_halfAR[4] = 15.00005;
        m_halfAR[5] = 25.00005;

        m_Tip_Clus[0] = 0.1;
        m_Tip_Clus[1] = 0.2;
        m_Tip_Clus[2] = 1;

        m_Tess_ValU[0] = 20;
        m_Tess_ValU[1] = 45;
        m_Tess_ValU[2] = 75;
        m_Tess_ValU[3] = 100;

        m_Tess_ValW[0] = 20;
        m_Tess_ValW[1] = 40;
        m_Tess_ValW[2] = 60;
        m_Tess_ValW[3] = 80;
    }
    
    void HersheyBarARTessStudy()
    {
        m_runflag = true;;
        
        //====Generate Hershey Bar AR Tess Study Wings====//
        GenerateHersheyBarARTessWings();
        
        //====Test Hershey Bar AR Tess Study====//
        // Testing various AR wings to study how large AR needs to be
        // to get close enough to 2D results
        TestHersheyBarARTessStudy();
    }

    private void GenerateHersheyBarARTessWings()
    {
        //==== Add Wing Geometry ====//
        string wing_id = AddGeom( "WING", "" );
        
        //==== Set Wing Section ====//
        SetDriverGroup( wing_id, 1, AR_WSECT_DRIVER, ROOTC_WSECT_DRIVER, TIPC_WSECT_DRIVER );
        
        Update();
        
        //==== Set NACA 0012 Airfoil and Common Parms 
        SetParmVal( wing_id, "ThickChord", "XSecCurve_0", 0.12 );
        SetParmVal( wing_id, "ThickChord", "XSecCurve_1", 0.12 );
        SetParmVal( wing_id, "Sweep", "XSec_1", 0 );
        SetParmVal( wing_id, "Root_Chord", "XSec_1", 1 );
        SetParmVal( wing_id, "Tip_Chord", "XSec_1", 1 );
        
        // Get Default Values for Resets
        const double Def_UTess = GetParmVal( wing_id, "SectTess_U", "XSec_1" );
        const double Def_WTess = GetParmVal( wing_id, "Tess_W", "Shape" );
        const double Def_TipClus = GetParmVal( wing_id, "OutCluster", "XSec_1" );
        
        Update();

        for ( uint8 x = 0; x < uint8(m_halfAR.length()); x++ )
        {
            SetParmVal( wing_id, "Aspect", "XSec_1", m_halfAR[x] );
            SetParmVal( wing_id, "SectTess_U", "XSec_1", Def_UTess );
            SetParmVal( wing_id, "Tess_W", "Shape", Def_WTess );
            SetParmVal( wing_id, "OutCluster", "XSec_1", Def_TipClus );

            Update();

            //==== Setup export filenames for AR Study ====//
            string fname_ARtest = "NACA0012_AR" + int(2*m_halfAR[x]) + ".vsp3";

            //==== Save Vehicle to File ====//
            Print("-->Saving vehicle file to: ", false );
            Print( fname_ARtest, true );
            Print( "" );
            WriteVSPFile( fname_ARtest, SET_ALL );
            Print( "COMPLETE\n" );
            
            if ( x != 0 && x != 2 && x != 4 ) // Skip evens 
            {
                for (uint8 q = 0; q < uint8(m_Tess_ValU.length()); q++ )
                {
                    for( uint8 r = 0; r < uint8(m_Tess_ValW.length()); r++)
                    {
                        for( uint8 k = 0; k < uint8(m_Tip_Clus.length()); k++)
                        {
                            //==== Setup filename for Tess Study ====//
                            string fname_tess = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Tess_U" + int(m_Tess_ValU[q]) + "_Tess_W" + int(m_Tess_ValW[r]) + "_Tip_" + 
                            double(m_Tip_Clus[k]) + ".vsp3";

                            // Increase tessellation amounts for each AR wing
                            SetParmVal( wing_id, "SectTess_U", "XSec_1", m_Tess_ValU[q] );
                            SetParmVal( wing_id, "Tess_W", "Shape", m_Tess_ValW[r] );
                            SetParmVal( wing_id, "OutCluster", "XSec_1", m_Tip_Clus[k] );

                            Update();

                            //==== Save Vehicle to File ====//
                            Print("-->Saving vehicle file to: ", false );
                            Print( fname_tess, true );
                            Print( "" );
                            WriteVSPFile( fname_tess, SET_ALL );
                            Print( "COMPLETE\n" );
                        }
                    }
                }
            }
        }
        ClearVSPModel();
    }
    
    private void TestHersheyBarARTessStudy()
    {
        Print( string( "-> Begin HersheyBar AR Tess Study:\n" ) );
        
        const uint8 num_AR = uint8(m_halfAR.length());
        const uint8 num_UTess = uint8(m_Tess_ValU.length());
        const uint8 num_WTess = uint8(m_Tess_ValW.length());
        const uint8 num_TC = uint8(m_Tip_Clus.length());
        
        array<array<array<double>>> Error_Tess_theo(num_AR), Error_Cl_theo(num_AR); // index 0: AR, index 1: UTess, index 2: WTess
        array<array<array<array<array<double>>>>> span_loc_data(num_AR), cl_dist_data(num_AR); // index 0: AR, index 1: UTess, index 2: WTess, index 3: Tip Cluster
        array<array<array<array<vec3d>>>> cl_dist_theo(num_AR);
        array<double> C_l_llt(num_AR);
        
        const double C_bot_two = 1 + (pow(tan(0.0),2)/pow(b,2));
        
        const uint8 num_alpha = 9; // Reduce Number of points for testing. TODO: Set to 9
        const double alpha_0 = -20.0;
        const double alpha_f = 20.0;
        const double d_alpha = alpha_f - alpha_0;
        const double Vinf = 100;
        double Sum_Err_Theo = 0.0;

        array<array<double>> alpha_vlm(num_AR), Cl_vlm(num_AR), Cl_approx(num_AR);
        array<double> Cl_alpha_vlm(num_AR), Lift_angle_vlm(num_AR), Lift_angle_theo(num_AR), AR(num_AR), C_ratio(num_AR), Cl_alpha_theo( num_AR ), Lift_angle_pm(num_AR), Cl_alpha_pm(num_AR);

        for ( uint8 x = 0; x < num_AR; x++ )
        {
            //==== AR Study ====//
            
            //==== Open and test generated wings ====//
            string fname_ARtest = "NACA0012_AR" + int(2*m_halfAR[x]) + ".vsp3";
            string fname_ARcsv_vlm = "NACA0012_AR" + int(2*m_halfAR[x]) + "vlm_res.csv";
            string fname_ARcsv_pm = "NACA0012_AR" + int(2*m_halfAR[x]) + "pm_res.csv";

            Print( string( "Reading in file: " ), false );
            Print( fname_ARtest );
            ReadVSPFile( fname_ARtest ); // Sets VSP3 file name

            //==== Analysis: VSPAero VLM Sweep ====//
            Print( m_VSPSweepAnalysis );

            //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
            Print( m_CompGeomAnalysis );

            // Set defaults
            SetAnalysisInputDefaults( m_CompGeomAnalysis );

            // list inputs, type, and current values
            PrintAnalysisInputs( m_CompGeomAnalysis );

            // Execute
            Print( "\tExecuting..." );
            string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( compgeom_resid );

            //==== Analysis: VSPAero VLM Sweep ====//
            // Set defaults
            SetAnalysisInputDefaults(m_VSPSweepAnalysis);
            Print(m_VSPSweepAnalysis);

            // Reference geometry set
            SetIntAnalysisInput(m_VSPSweepAnalysis, "GeomSet", m_GeomVec, 0);
            SetIntAnalysisInput(m_VSPSweepAnalysis, "RefFlag", m_RefFlagVec, 0);

            array< string > wid = FindGeomsWithName( "WingGeom" );
            SetStringAnalysisInput(m_VSPSweepAnalysis, "WingID", wid, 0);
            
            SetIntAnalysisInput(m_VSPSweepAnalysis, "WakeNumIter", m_WakeIterVec, 0);
            
            // Freestream Parameters
            Print( "\tExecuting input Parameters..." );
            array<double> AlphaStart(1, alpha_0);
            array<double> AlphaEnd(1, alpha_f);
            array<int> AlphaNpts(1, num_alpha);
            SetDoubleAnalysisInput(m_VSPSweepAnalysis, "AlphaStart", AlphaStart, 0);
            SetDoubleAnalysisInput(m_VSPSweepAnalysis, "AlphaEnd", AlphaEnd, 0);
            SetIntAnalysisInput(m_VSPSweepAnalysis, "AlphaNpts", AlphaNpts, 0);
            array<double> MachNpts(1, 1); // Start and end at 0.1
            SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachStart", m_MachVec, 0);
            SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachEnd", m_MachVec, 0);
            SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachNpts", MachNpts, 0);

            Update();

            // list inputs, type, and current values
            PrintAnalysisInputs( m_VSPSweepAnalysis );
            Print( "" );

            // Execute
            Print( "\tExecuting..." );
            string rid = ExecAnalysis( m_VSPSweepAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( rid );
            WriteResultsCSVFile( rid, fname_ARcsv_vlm );
            
            // Get Result ID Vec (History and Load ResultIDs)
            array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
            
            // Calculate Experimental and Theoretical Values
            // Fluid -Dynamic Lift pg 3-2
            // Method 1 of USAF DATCOM Section 1, page 1-7, and also NACA TN-3911)
            AR[x] = 2*m_halfAR[x];
            double C_top = 2*pi*AR[x];
            double C_bot_one_theo = (pow(AR[x],2)*pow(b,2))/pow(k_theo,2);
            double C_bot_theo = (2 + (sqrt((C_bot_one_theo*C_bot_two)+4)));
            Cl_alpha_theo[x] = (C_top/C_bot_theo)*(pi/180); // deg
            Lift_angle_theo[x] = 1/(Cl_alpha_theo[x]); // Cl to lift angle (deg)
            C_ratio[x] = 1/AR[x]; // AR to chord ratio
            
            if ( rid_vec.length() >= 1 )
            {
                array<double> alpha_res( num_alpha ), Cd_tot_res( num_alpha ), Cd_i_res( num_alpha ), Cl_res( num_alpha ), L_D_res( num_alpha ), Cl_approx_vec( num_alpha );
                
                // Get Result from Final Wake Iteration
                for ( uint8 i = 0; i < num_alpha; i++ )
                {
                    array<double> alpha_vec = GetDoubleResults( rid_vec[i], "Alpha" );
                    alpha_res[i] = alpha_vec[int(alpha_vec.length()) - 1];
                    
                    array<double> cl_vec = GetDoubleResults( rid_vec[i], "CL" );
                    Cl_res[i] = cl_vec[int(cl_vec.length()) - 1];
                    
                    Cl_approx_vec[i] = 2 * pi * sin( Deg2Rad( alpha_res[i] ) );
                }
                
                Cl_alpha_vlm[x] = ((Cl_res[int(alpha_res.length()) - 1] - Cl_res[0])/d_alpha); // deg
                
                alpha_vlm[x] = alpha_res;
                Cl_vlm[x] = Cl_res;
                Cl_approx[x] = Cl_approx_vec;
                
                Lift_angle_vlm[x] = 1/(Cl_alpha_vlm[x]); // deg
            }

            // Add error
            Sum_Err_Theo += abs(Lift_angle_vlm[x] - Lift_angle_theo[x])/abs(Lift_angle_theo[x]);
            
            //==== Analysis: VSPAero Panel Single ====//
            Print( m_VSPSingleAnalysis );
            
            // Find and delete VLM MeshGeom
            array< string > mid = FindGeomsWithName( "MeshGeom" );
            DeleteGeomVec( mid );
            Update();
            
            //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
            Print( m_CompGeomAnalysis );

            // Set defaults
            SetAnalysisInputDefaults( m_CompGeomAnalysis );
            
            array<int> panel_analysis(1, VSPAERO_ANALYSIS_METHOD::PANEL);
            SetIntAnalysisInput( m_CompGeomAnalysis, "AnalysisMethod", panel_analysis );

            // list inputs, type, and current values
            PrintAnalysisInputs( m_CompGeomAnalysis );

            // Execute
            Print( "\tExecuting..." );
            compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( compgeom_resid );
            
            //==== Analysis: VSPAero Panel Single ====//
           // Set defaults
            SetAnalysisInputDefaults(m_VSPSingleAnalysis);
            Print(m_VSPSingleAnalysis);

            // Reference geometry set
            SetIntAnalysisInput(m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0);
            SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);
            SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);
            SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);
            SetIntAnalysisInput( m_VSPSingleAnalysis, "AnalysisMethod", panel_analysis );
            
            // Freestream Parameters
            Print( "\tExecuting input Parameters..." );
            array<double> Alpha(1, 1);
            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);

            Update();

            // list inputs, type, and current values
            PrintAnalysisInputs( m_VSPSingleAnalysis );
            Print( "" );

            // Execute
            Print( "\tExecuting..." );
            rid = ExecAnalysis( m_VSPSingleAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( rid );
            WriteResultsCSVFile( rid, fname_ARcsv_pm );
            
            // Get Result ID Vec (History and Load ResultIDs)
            rid_vec = GetStringResults( rid, "ResultsVec" );
            
            if ( rid_vec.length() > 0 )
            {
                // Get Result from Final Wake Iteration
                array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                
                double Cl_pm = cl_vec[int(cl_vec.length()) - 1];
                Cl_alpha_pm[x] = Cl_pm; // deg (alpha = 1.0°)
                Lift_angle_pm[x] = 1/(Cl_alpha_pm[x]); // deg
            }

            ClearVSPModel();
            
            //==== Tesselation Study ====//
            if ( x != 0 && x != 2 && x != 4 ) // Skip evens 
            {
                Error_Tess_theo[x].resize(num_UTess);
                span_loc_data[x].resize(num_UTess);
                cl_dist_data[x].resize(num_UTess);
                cl_dist_theo[x].resize(num_UTess);
                
                for (uint8 q = 0; q < num_UTess; q++ )
                {
                    //Error_Tess_exp[x][q].resize(num_WTess);
                    Error_Tess_theo[x][q].resize(num_WTess);
                    span_loc_data[x][q].resize(num_WTess);
                    cl_dist_data[x][q].resize(num_WTess);
                    cl_dist_theo[x][q].resize(num_WTess);
                    
                    for( uint8 r = 0; r < num_WTess; r++)
                    {
                        span_loc_data[x][q][r].resize(num_TC);
                        cl_dist_data[x][q][r].resize(num_TC);
                        
                        for( uint8 k = 0; k < num_TC; k++)
                        {
                            string fname_tess = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Tess_U" + int(m_Tess_ValU[q]) + "_Tess_W" + int(m_Tess_ValW[r]) + "_Tip_" + 
                            double(m_Tip_Clus[k]) + ".vsp3";
                            string fname_tess_csv = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Tess_U" + int(m_Tess_ValU[q]) + "_Tess_W" + int(m_Tess_ValW[r]) + "_Tip_" + 
                            double(m_Tip_Clus[k]) + "_res.csv";
                            
                            //==== Open and test generated wings ====//
                            Print( string( "Reading in file: " ), false );
                            Print( fname_tess );
                            ReadVSPFile( fname_tess ); // Sets VSP3 file name

                            //==== Analysis: VSPAEROSinglePoint ====//
                            Print( m_VSPSingleAnalysis );

                            //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                            Print( m_CompGeomAnalysis );

                            // Set defaults
                            SetAnalysisInputDefaults( m_CompGeomAnalysis );

                            // list inputs, type, and current values
                            PrintAnalysisInputs( m_CompGeomAnalysis );

                            // Execute
                            Print( "\tExecuting..." );
                            compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                            Print( "COMPLETE" );

                            // Get & Display Results
                            PrintResults( compgeom_resid );

                            //==== Analysis: VSPAero Single Point ====//
                            // Set defaults
                            SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                            Print(m_VSPSingleAnalysis);

                            // Reference geometry set
                            SetIntAnalysisInput(m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0);
                            SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

                            wid = FindGeomsWithName( "WingGeom" );
                            SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);

                            // Freestream Parameters
                            Print( "\tExecuting input Parameters..." );
                            array<double> alpha(1, 1.0);
                            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", alpha, 0);
                            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);
                            SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

                            Update();

                            // list inputs, type, and current values
                            PrintAnalysisInputs( m_VSPSingleAnalysis );
                            Print( "" );

                            // Execute
                            Print( "\tExecuting..." );
                            rid = ExecAnalysis( m_VSPSingleAnalysis );
                            Print( "COMPLETE" );

                            // Get & Display Results
                            PrintResults( rid );
                            WriteResultsCSVFile( rid, fname_tess_csv );

                            // Get Result ID Vec (History and Load ResultIDs)
                            rid_vec = GetStringResults( rid, "ResultsVec" );
                            if ( rid_vec.length() > 0 )
                            {
                                // Get History Results (rid_vec[0]) from Final Wake Iteration in History Result
                                array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                                double Cl_res_tess = cl_vec[int(cl_vec.length()) - 1];
                                
                                // Calculate Error
                                double C_l_alpha_vsp = Cl_res_tess; // deg
                                Error_Tess_theo[x][q][r] = (abs(C_l_alpha_vsp - Cl_alpha_theo[x])/abs(Cl_alpha_theo[x]))*100;
                                
                                // Lift Distribution:
                                string load_rid = rid_vec[1];
                                
                                array<double> span_dist_vec = GetDoubleResults( load_rid, "Yavg" );
                                array<double> cl_dist_vec = GetDoubleResults( load_rid, "cl" );

                                // Sort distribution vectors in ascending order
                                array<double> new_span_vec, new_cl_vec, check_span_vec;
                                
                                for ( int i = int(span_dist_vec.length()) - 1; i > (int(span_dist_vec.length())/2) - 1; i-- )
                                {
                                    new_span_vec.push_back( span_dist_vec[i] );
                                    new_cl_vec.push_back( cl_dist_vec[i] );
                                }
                                for ( int i = 0; i < (int(span_dist_vec.length())/2); i++ )
                                {
                                    new_span_vec.push_back( span_dist_vec[i] );
                                    new_cl_vec.push_back( cl_dist_vec[i] );
                                }
                                
                                span_loc_data[x][q][r][k] = new_span_vec;
                                cl_dist_data[x][q][r][k] = new_cl_vec;
                                
                                // Compute theoretical lift distribution
                                if ( k == 0 )
                                {
                                    cl_dist_theo[x][q][r] = GetHersheyBarLiftDist( int(span_dist_vec.length())/2, Deg2Rad(Alpha[0]), Vinf, (2*m_halfAR[x]), true );
                                }
                            }
                            
                            ClearVSPModel();
                        }
                    }
                }
            }
        }

        // Hershey Bar -- C_L vs Alpha  for Various AR
        HTMLChart c1 = HTMLChart(); // Initialize Chart
        c1.m_ChartName = string("CLvA");
        c1.m_Series = string("{ 6: { pointSize: 0, color: 'gray', lineWidth: 2 } }");
        c1.m_Legend = string("'Alpha','5','7','10','20','30','50','Thin Approximation'");
        c1.m_Title = string("Hershey Bar VLM: Cl vs Alpha for Various AR");
        c1.m_HAxisString = string("hAxis: { title: 'Alpha (°)', titleTextStyle: { bold: true } }");
        c1.m_VAxisString = string("vAxis: { title: 'Cl', titleTextStyle: { bold: true } }");
        
        array<string> data_str_vec1;
        for( uint i = 0; i < num_alpha; i++ )
        {
            string row = string("\t\t  [") + double( alpha_vlm[0][i] ) + string(",");

            for ( uint j = 0; j < num_AR; j++ )
            {
                row += Cl_vlm[j][i];
                row += string(",");
            }

            row += Cl_approx[0][i];

            if ( i == num_alpha - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec1.push_back( row );
        }
        
        c1.WriteChartHead( data_str_vec1 );
        m_HersheyARIDVec.push_back( c1.m_ChartName );

        // Hershey Bar: C_Lalpha vs AR for Various AR
        HTMLChart c2 = HTMLChart(); // Initialize Chart
        c2.m_ChartName = string("CLavAR");
        c2.m_Series = string("{ 2: { pointSize: 0,  color: 'gray', lineWidth: 3 } }");
        c2.m_Legend = string("'AR','VSPAERO VLM','VSPAERO Panel','Theoretical Approximation'");
        c2.m_Title = string("Hershey Bar: Cl_alpha vs AR");
        c2.m_HAxisString = string("hAxis: { title: 'AR', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        c2.m_VAxisString = string("vAxis: { title: 'Cl_alpha (°)', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        
        array<string> data_str_vec2;
        for( uint i = 0; i < num_AR; i++ )
        {
            string row = string("\t\t  [") + double( AR[i] ) + string(",") + double( Cl_alpha_vlm[i] ) + string(",") + double( Cl_alpha_pm[i] ) + 
                string(",") + double( Cl_alpha_theo[i] );

            if ( i == num_AR - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec2.push_back( row );
        }
        
        c2.WriteChartHead( data_str_vec2 );
        m_HersheyARIDVec.push_back( c2.m_ChartName );
        
        // Hershey Bar:  Lift Angle vs. Chord Ratio
        HTMLChart c3 = HTMLChart(); // Initialize Chart
        c3.m_ChartName = string("LAvCR");
        c3.m_Legend = string("'1/AR','VSPAERO VLM','VSPAERO Panel','3D Theoretical Approximation'");
        c3.m_Series = string("{ 2: { pointSize: 0, color: 'gray', lineWidth: 3 } }");
        c3.m_Title = string("Hershey Bar: Lift Angle vs. Chord Ratio");
        c3.m_HAxisString = string("hAxis: { title: '1/AR', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        c3.m_VAxisString = string("vAxis: { title: 'd_alpha/d_Cl (°)', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");

        array<string> data_str_vec3;
        for( uint i = 0; i < num_AR; i++ )
        {
            string row = string("\t\t  [") + double( C_ratio[i] ) + string(",") + double( Lift_angle_vlm[i] ) + string(",") + double( Lift_angle_pm[i] ) + 
                string(",")  + double( Lift_angle_theo[i] );

            if ( i == num_AR - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec3.push_back( row );
        }
        
        c3.WriteChartHead( data_str_vec3 );
        m_HersheyARIDVec.push_back( c3.m_ChartName );
        
        // Compute Error
        m_Hershey_AR60_Cl_alpha_Err = (abs(Cl_alpha_vlm[int(m_halfAR.length()) - 1] - Cl_alpha_theo[int(m_halfAR.length()) - 1])/abs(Cl_alpha_theo[int(m_halfAR.length()) - 1]))*100;
        
        Print( string( "The percent error between VSPAERO AR = 60 and Thin airfoil theory is:" ), false );
        Print( m_Hershey_AR60_Cl_alpha_Err, false );
        Print( string( "%" ) );
        
        double Err_Theo = (Sum_Err_Theo/num_AR)*100;

        Print( string( "The average percent error between VSPAERO and theoreticl approximate results is:" ), false );
        Print( Err_Theo, false );
        Print( string( "%" ) );
        
        for ( uint8 x = 0; x < num_AR; x++ )
        {
            if ( x != 0 && x != 2 && x != 4 ) // Skip evens 
            {
                // Hershey Bar VLM: % Dif of C_l\alpha using Lifting Line Theory for Various AR with Tip Clustering = 1.0
                // Chord Tess
                HTMLChart c4 = HTMLChart(); // Initialize Chart
                c4.m_ChartName = string("ChordAR") + int(2*m_halfAR[x]);
                c4.m_Legend = string("'Chord Tesselation','20','45','75','100'");
                c4.m_Title = string("Hershey Bar VLM: % Error of VSPAERO and Theoretical Cl_alpha of Various Span Tesselation for AR = ") + int(2*m_halfAR[x]);
                c4.m_HAxisString = string("hAxis: { title: 'Chord Tesselation', titleTextStyle: { bold: true } }");
                c4.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
                c4.m_Width = 0.38;
                
                array<string> data_str_vec4;
                for( uint i = 0; i < num_WTess; i++ )
                {
                    string row = string("\t\t  [") + double( m_Tess_ValW[i] ) + string(",") + double( Error_Tess_theo[x][0][i] ) + 
                        string(",") + double( Error_Tess_theo[x][1][i] ) + string(",") + double( Error_Tess_theo[x][2][i] ) + string(",") + 
                        double( Error_Tess_theo[x][3][i] );

                    if ( i == num_WTess - 1 )
                    {
                        row += string("]\n");
                    }
                    else
                    {
                        row += string("],\n");
                    }
                    
                    data_str_vec4.push_back( row );
                }
                
                c4.WriteChartHead( data_str_vec4 );
                m_HersheyTessIDVec.push_back( c4.m_ChartName );
                
                // Span Tess
                HTMLChart c5 = HTMLChart(); // Initialize Chart
                c5.m_ChartName = string("SpanAR") + int(2*m_halfAR[x]);
                c5.m_Legend = string("'Span Tesselation','20','40','60','80'");
                c5.m_Title = string("Hershey Bar VLM: % Error of VSPAERO and Theoretical Cl_alpha of Various Chord Tesselation for AR = ") + int(2*m_halfAR[x]);
                c5.m_HAxisString = string("hAxis: { title: 'Span Tesselation', titleTextStyle: { bold: true } }");
                c5.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
                c5.m_Width = 0.38;
                
                array<string> data_str_vec5;
                for( uint i = 0; i < num_UTess; i++ )
                {
                    string row = string("\t\t  [") + double( m_Tess_ValU[i] ) + string(",") + double( Error_Tess_theo[x][i][0] ) + 
                        string(",") + double( Error_Tess_theo[x][i][1] ) + string(",") + double( Error_Tess_theo[x][i][2] ) + string(",") + 
                        double( Error_Tess_theo[x][i][3] );

                    if ( i == num_UTess - 1 )
                    {
                        row += string("]\n");
                    }
                    else
                    {
                        row += string("],\n");
                    }
                    
                    data_str_vec5.push_back( row );
                }
                
                c5.WriteChartHead( data_str_vec5 );
                m_HersheyTessIDVec.push_back( c5.m_ChartName );
                
                // Hershey Bar VLM: Lift Distribution for Various AR and Tesselation
                for (uint8 q = 0; q < num_UTess; q++ )
                {
                    for( uint8 r = 0; r < num_WTess; r++)
                    {
                        HTMLChart c6 = HTMLChart(); // Initialize Chart
                        c6.m_ChartName = string("LD_AR") + int(2*m_halfAR[x]) + string("_U") + int(m_Tess_ValU[q]) + string("_W") + int(m_Tess_ValW[r]);
                        c6.m_Legend = string("'Span Location','TC: 0.1','TC: 0.2','TC: 1.0','3D Approximation'");
                        c6.m_Series = string("{ 3: { pointSize: 0, color: 'gray', lineWidth: 3 } }");
                        c6.m_Title = string("Lift Distribution of Various Tip Clustering Compared to Lifting Line Theory for AR = ") + int(2*m_halfAR[x]) + 
                            string(", Span Tess = ") + int(m_Tess_ValU[q]) + string(", Chord Tess = ") + int(m_Tess_ValW[r]);
                        c6.m_HAxisString = string("hAxis: { title: 'Span Location (Y)', titleTextStyle: { bold: true } }");
                        c6.m_VAxisString = string("vAxis: { title: 'Cl', titleTextStyle: { bold: true }, viewWindow: { min: 0.0, max: 0.15 } }");
                        
                        // TODO: span_loc_data[x][q][r][0] only corresponds exactly to cl_dist_data[x][q][r][0]. Need to use span_loc_data[x][q][r][1] for cl_dist_data[x][q][r][1], etc. (see VKT plot) (Could call interpNULLS in Google Charts API)
                        array<string> data_str_vec6;
                        for( uint i = 0; i < uint(span_loc_data[x][q][r][0].length()); i++ )
                        {
                            string row = string("\t\t  [") + double( span_loc_data[x][q][r][0][i] ) + string(",") + double( cl_dist_data[x][q][r][0][i] ) + 
                                string(",") + double( cl_dist_data[x][q][r][1][i] ) + string(",") + double( cl_dist_data[x][q][r][2][i] )+ string(",") + 
                                double( cl_dist_theo[x][q][r][i][1] );

                            if ( i == span_loc_data[x][q][r][0].length() - 1 )
                            {
                                row += string("]\n");
                            }
                            else
                            {
                                row += string("],\n");
                            }
                            
                            data_str_vec6.push_back( row );
                        }
                        
                        c6.WriteChartHead( data_str_vec6 );
                        m_HersheyLDIDVec.push_back( c6.m_ChartName );
                    }
                }
            }
        }
    }
    
    // Hershey Bar Class Properties
    private array<double> m_halfAR(6);
    private array<double> m_Tip_Clus(3);
    private array<int> m_Tess_ValU(4);
    private array<int> m_Tess_ValW(4);
    
    array<string> m_HersheyARIDVec;
    array<string> m_HersheyTessIDVec;
    array<string> m_HersheyLDIDVec;
    array<string> m_HersheyARppIDVec;
    
    double m_Hershey_AR60_Cl_alpha_Err;
    double m_Hershey_LA_Err;
}

//============= Swept Wing Study Functions ==============//
class SweepVV : VV_Base
{
    SweepVV()
    {
        m_halfAR[0] = 2.5005;
        m_halfAR[1] = 5.001;
        m_halfAR[2] = 7.5005;
        m_halfAR[3] = 12.5;
        m_halfAR[4] = 20.0;
        m_halfAR[5] = 30.001;
        
        m_Tip_Clus[0] = 1;
        
        m_Tess_ValU[0] = 20;
        m_Tess_ValU[1] = 45;
        m_Tess_ValU[2] = 75;
        m_Tess_ValU[3] = 100;

        m_Tess_ValW[0] = 20;
        m_Tess_ValW[1] = 40;
        m_Tess_ValW[2] = 60;
        m_Tess_ValW[3] = 80;
        
        m_Sweep[0] = 10;
        m_Sweep[1] = 20;
        m_Sweep[2] = 30;
        m_Sweep[3] = 40;
    }
    
    void SweepARTessStudy()
    {
        m_runflag = true;
        
        //====Generate Wings====//
        GenerateSweepARTessStudyWings();
        
        //====Test Wings====//
        // Testing various AR wings to study how large AR needs to be
        // to get close enough to 2D results
        TestSweepARTessStudyWings();
    }
    
    private void GenerateSweepARTessStudyWings()
    {
        //==== Add Wing Geometry ====//
        string wing_id = AddGeom( "WING", "" );

        //==== Set Wing Section ====//
        SetDriverGroup( wing_id, 1, AR_WSECT_DRIVER, ROOTC_WSECT_DRIVER, TIPC_WSECT_DRIVER );
        
        Update();

        //==== Set Airfoil NACA0012 and Set Common Parms ====//
        SetParmVal( wing_id, "ThickChord", "XSecCurve_0", 0.12 );
        SetParmVal( wing_id, "ThickChord", "XSecCurve_1", 0.12 );
        SetParmVal( wing_id, "Sweep_Location", "XSec_1", 0.5 ); // Source of Errors?
        SetParmVal( wing_id, "Sweep", "XSec_1", 35 );
        SetParmVal( wing_id, "Root_Chord", "XSec_1", 1 );
        SetParmVal( wing_id, "Tip_Chord", "XSec_1", 1 );
        
        // Get Default Values for Resets
        const double Def_UTess = GetParmVal( wing_id, "SectTess_U", "XSec_1" );
        const double Def_WTess = GetParmVal( wing_id, "Tess_W", "Shape" );
        const double Def_TipClus = GetParmVal( wing_id, "OutCluster", "XSec_1" );
        
        Update();
        
        for ( uint8 x = 0; x < uint8(m_halfAR.length()); x++ )
        {
            SetParmVal( wing_id, "Aspect", "XSec_1", m_halfAR[x] );
            SetParmVal( wing_id, "Tess_W", "Shape", Def_WTess );
            SetParmVal( wing_id, "SectTess_U", "XSec_1", Def_UTess );
            SetParmVal( wing_id, "OutCluster", "XSec_1", Def_TipClus );

            Update();

            //==== Setup export filenames for AR Study ====//
            string fname_ARtest = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep_35.vsp3";

            //==== Save Vehicle to File ====//
            Print("-->Saving vehicle file to: ", false );
            Print( fname_ARtest, true );
            Print( "" );
            WriteVSPFile( fname_ARtest, SET_ALL );
            Print( "COMPLETE\n" );
            
            for ( uint8 q = 0; q < uint8(m_Tess_ValU.length()); q++ )
            {
                for ( uint8 r = 0; r < uint8(m_Tess_ValW.length()); r++ )
                {
                    for( uint8 k = 0; k < uint8(m_Tip_Clus.length()); k++)
                    {
                        // Increase tessellation amounts for each AR wing
                        SetParmVal( wing_id, "Tess_W", "Shape", m_Tess_ValW[r]);
                        SetParmVal( wing_id, "SectTess_U", "XSec_1", m_Tess_ValU[q] );
                        SetParmVal( wing_id, "OutCluster", "XSec_1", m_Tip_Clus[k] );

                        Update();

                        //==== Setup export filenames ====//
                        string fname_tess = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Tess_U" + int(m_Tess_ValU[q]) + "_Tess_W" + int(m_Tess_ValW[r]) + "_Tip_" + 
                            double(m_Tip_Clus[k]) + "_Sweep_35.vsp3";

                        //==== Save Vehicle to File ====//
                        Print("-->Saving vehicle file to: ", false );
                        Print( fname_tess, true );
                        Print( "" );
                        WriteVSPFile( fname_tess, SET_ALL );
                        Print( "COMPLETE\n" );
                    }
                }
            }
        }
        
        ClearVSPModel();
    }

    private void TestSweepARTessStudyWings()
    {
        Print( string( "-> Begin Sweep AR Tess Study:\n" ) );

        const uint8 num_AR = uint8(m_halfAR.length());
        const uint8 num_UTess = uint8(m_Tess_ValU.length());
        const uint8 num_WTess = uint8(m_Tess_ValW.length());
        const uint8 num_TC = uint8(m_Tip_Clus.length());
        
        array<array<array<double>>> Error_Tess_theo(num_AR); // index 0: AR, index 1: UTess, index 3: WTess
        
        const double sweep = 35; // deg
        const double C_bot_two = 1 + (pow((tan(Deg2Rad(sweep))),2)/pow(b,2));
        
        double Sum_Err_Theo = 0.0;
        
        array<double> Lift_angle_vlm(num_AR), Lift_angle_theo(num_AR), C_ratio(num_AR), Lift_angle_pm(num_AR);

        for ( uint8 x = 0; x < num_AR; x++ )
        {
            //==== AR Study ====//
            
            //==== Open and test generated wings ====//
            string fname_ARtest = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep_35.vsp3";
            string fname_ARcsv_vlm = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep_35_vlm_res.csv";
            string fname_ARcsv_pm = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep_35_pm_res.csv";

            Print( string( "Reading in file: " ), false );
            Print( fname_ARtest );
            ReadVSPFile( fname_ARtest ); // Sets VSP3 file name

            //==== Analysis: VSPAEROSinglePoint ====//
            Print( m_VSPSingleAnalysis );

            //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
            Print( m_CompGeomAnalysis );

            // Set defaults
            SetAnalysisInputDefaults( m_CompGeomAnalysis );

            // list inputs, type, and current values
            PrintAnalysisInputs( m_CompGeomAnalysis );

            // Execute
            Print( "\tExecuting..." );
            string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( compgeom_resid );

            //==== Analysis: VSPAEROSinglePoint ====//
            // Set defaults
            SetAnalysisInputDefaults(m_VSPSingleAnalysis);
            Print(m_VSPSingleAnalysis);

            // Reference geometry set
            SetIntAnalysisInput( m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0 );
            SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

            array< string > wid = FindGeomsWithName( "WingGeom" );
            SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);
            
            SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

            // Freestream Parameters
            Print( "\tExecuting input Parameters..." );
            array<double> Alpha(1, 1.0);
            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);

            Update();

            // list inputs, type, and current values
            PrintAnalysisInputs( m_VSPSingleAnalysis );
            Print( "" );

            // Execute
            Print( "\tExecuting..." );
            string rid = ExecAnalysis( m_VSPSingleAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( rid );
            WriteResultsCSVFile( rid, fname_ARcsv_vlm );

            // Get Result ID Vec (History and Load ResultIDs)
            array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
            
            // Calculate Experimental and Theoretical Values
            double C_top = 2*pi*2*m_halfAR[x];
            double C_bot_one_theo = (pow((2*m_halfAR[x]),2)*pow(b,2))/pow(k_theo,2);
            double C_bot_theo = (2 + (sqrt((C_bot_one_theo*C_bot_two)+4)));
            double C_l_alpha_theo = (C_top/C_bot_theo)*(pi/180); // deg
            Lift_angle_theo[x] = 1/C_l_alpha_theo; // Cl to lift angle (deg)
            C_ratio[x] = 1/(2*m_halfAR[x]); // AR to chord ratio
            
            if ( rid_vec.length() >= 1 )
            {
                array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                double Cl_res = cl_vec[int(cl_vec.length()) - 1];
                double C_l_alpha_vsp = Cl_res; // alpha = 1.0 (deg)

                Lift_angle_vlm[x] = 1/(C_l_alpha_vsp); // deg
            }
            
            Sum_Err_Theo += abs(Lift_angle_vlm[x] - Lift_angle_theo[x])/abs(Lift_angle_theo[x]);
            
            //==== Analysis: VSPAero Panel Single ====//
            Print( m_VSPSingleAnalysis );
            
            // Find and delete VLM MeshGeom
            array< string > mid = FindGeomsWithName( "MeshGeom" );
            DeleteGeomVec( mid );
            Update();

            //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
            Print( m_CompGeomAnalysis );

            // Set defaults
            SetAnalysisInputDefaults( m_CompGeomAnalysis );
            
            array<int> panel_analysis(1, VSPAERO_ANALYSIS_METHOD::PANEL);
            SetIntAnalysisInput( m_CompGeomAnalysis, "AnalysisMethod", panel_analysis );

            // list inputs, type, and current values
            PrintAnalysisInputs( m_CompGeomAnalysis );

            // Execute
            Print( "\tExecuting..." );
            compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( compgeom_resid );
            
            //==== Analysis: VSPAero Panel Single ====//
           // Set defaults
            SetAnalysisInputDefaults(m_VSPSingleAnalysis);
            Print(m_VSPSingleAnalysis);

            // Reference geometry set
            SetIntAnalysisInput(m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0);
            SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);
            SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);
            SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);
            SetIntAnalysisInput( m_VSPSingleAnalysis, "AnalysisMethod", panel_analysis );
            
            // Freestream Parameters
            Print( "\tExecuting input Parameters..." );
            array<double> alpha(1, 1);
            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", alpha, 0);
            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);

            Update();

            // list inputs, type, and current values
            PrintAnalysisInputs( m_VSPSingleAnalysis );
            Print( "" );

            // Execute
            Print( "\tExecuting..." );
            rid = ExecAnalysis( m_VSPSingleAnalysis );
            Print( "COMPLETE" );

            // Get & Display Results
            PrintResults( rid );
            WriteResultsCSVFile( rid, fname_ARcsv_pm );
            
            // Get Result ID Vec (History and Load ResultIDs)
            rid_vec = GetStringResults( rid, "ResultsVec" );
            
            if ( rid_vec.length() > 0 )
            {
                // Get Result from Final Wake Iteration
                array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                
                double Cl_pm = cl_vec[int(cl_vec.length()) - 1];
                double Cl_alpha_pm = Cl_pm; // deg (alpha = 1.0°)
                Lift_angle_pm[x] = 1/(Cl_alpha_pm); // deg
            }
            
            ClearVSPModel();
            
            //==== Tesselation Study ====//
            
            if ( x != 0 && x != 2 && x != 4 ) // Skip Some 
            {
                Error_Tess_theo[x].resize(num_UTess);
                
                for (uint8 q = 0; q < num_UTess; q++ )
                {
                    Error_Tess_theo[x][q].resize(num_WTess);
                    
                    for( uint8 r = 0; r < num_WTess; r++)
                    {
                        for( uint8 k = 0; k < num_TC; k++)
                        {
                            //==== Open and test generated wings ====//
                            string fname_tess = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Tess_U" + int(m_Tess_ValU[q]) + "_Tess_W" + int(m_Tess_ValW[r]) + "_Tip_" + 
                                double(m_Tip_Clus[k]) + "_Sweep_35.vsp3";
                            string fname_tesscsv = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Tess_U" + int(m_Tess_ValU[q]) + "_Tess_W" + int(m_Tess_ValW[r]) + "_Tip_" + 
                                double(m_Tip_Clus[k]) + "_Sweep_35_res.csv";

                            Print( string( "Reading in file: " ), false );
                            Print( fname_tess );
                            ReadVSPFile( fname_tess ); // Sets VSP3 file name

                            //==== Analysis: VSPAeroSinglePoint ====//
                            Print( m_VSPSingleAnalysis );

                            //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                            Print( m_CompGeomAnalysis );

                            // Set defaults
                            SetAnalysisInputDefaults( m_CompGeomAnalysis );

                            // list inputs, type, and current values
                            PrintAnalysisInputs( m_CompGeomAnalysis );

                            // Execute
                            Print( "\tExecuting..." );
                            compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                            Print( "COMPLETE" );

                            // Get & Display Results
                            PrintResults( compgeom_resid );

                            //==== Analysis: VSPAero Single Point ====//
                            // Set defaults
                            SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                            Print(m_VSPSingleAnalysis);

                            // Reference geometry set
                            SetIntAnalysisInput( m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0 );
                            SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

                            SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);

                            // Freestream Parameters
                            Print( "\tExecuting input Parameters..." );
                            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
                            SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);
                            SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

                            Update();

                            // list inputs, type, and current values
                            PrintAnalysisInputs( m_VSPSingleAnalysis );
                            Print( "" );

                            // Execute
                            Print( "\tExecuting..." );
                            rid = ExecAnalysis( m_VSPSingleAnalysis );
                            Print( "COMPLETE" );

                            // Get & Display Results
                            PrintResults( rid );
                            WriteResultsCSVFile( rid, fname_tesscsv );

                            // Get Result ID Vec (History and Load ResultIDs)
                            rid_vec = GetStringResults( rid, "ResultsVec" );
                            if ( rid_vec.length() > 0 )
                            {
                                // Get History Results (rid_vec[0]) from Final Wake Iteration in History Result
                                array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                                double Cl_res = cl_vec[int(cl_vec.length()) - 1];

                                // Calculate Error
                                double C_l_alpha_vsp = Cl_res; // alpha = 1.0 (deg)
                                Error_Tess_theo[x][q][r] = (abs(C_l_alpha_vsp - C_l_alpha_theo)/abs(C_l_alpha_theo))*100;
                            }
                            
                            ClearVSPModel();
                        }
                    }
                }
            }
        }
        
        // 35° Swept Wing: Lift Angle vs. Chord Ratio 
        HTMLChart c1 = HTMLChart(); // Initialize Chart
        c1.m_ChartName = string("LAvCR_35");
        c1.m_Legend = string("'1/AR','VSPAERO VLM','VSPAERO Panel','3D Theoretical Approx'");
        c1.m_Series = string("{ 2: { pointSize: 0, color: 'gray', lineWidth: 3 } }");
        c1.m_Title = string("35° Sweep: Lift Angle vs Chord Ratio");
        c1.m_HAxisString = string("hAxis: { title: '1/AR', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        c1.m_VAxisString = string("vAxis: { title: 'd_a/d_C_l (°)', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");

        array<string> data_str_vec1;
        for( uint i = 0; i < num_AR; i++ )
        {
            string row = string("\t\t  [") + double( C_ratio[i] ) + string(",") + double( Lift_angle_vlm[i] ) + string(",") + double( Lift_angle_pm[i] ) + 
                string(",") + double( Lift_angle_theo[i] );

            if ( i == num_AR - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec1.push_back( row );
        }
        
        c1.WriteChartHead( data_str_vec1 );
        m_SweepARIDVec.push_back( c1.m_ChartName );
        
        //double Err_Exp = (Sum_Err_Exp/num_AR)*100;
        m_35Sweep_LA_Err = (Sum_Err_Theo/num_AR)*100;

        Print( string( "The percent error between VSPAERO and theoretical results is:" ), false );
        Print( m_35Sweep_LA_Err, false );
        Print( string( "%" ) );
        
        // 35° Swept Wing VLM: % Dif of C_l\alpha using Theoretical Methods for Various AR
        for ( uint8 x = 0; x < num_AR; x++ )
        {
            if ( x != 0 && x != 2 && x != 4 ) // Skip Some 
            {
                // Chord Tess
                HTMLChart c2 = HTMLChart(); // Initialize Chart
                c2.m_ChartName = string("ChordAR") + int(2*m_halfAR[x]) + string("_Sweep35");
                c2.m_Legend = string("'Chord Tesselation','20','45','75','100'");
                c2.m_Title = string("35° Sweep VLM: % Error of VSPAERO and Theoretical Cl_alpha of Various Span Tesselation for AR = ") + int(2*m_halfAR[x]);
                c2.m_HAxisString = string("hAxis: { title: 'Chord Tess', titleTextStyle: { bold: true } }");
                c2.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
                c2.m_Width = 0.38;
                
                array<string> data_str_vec2;
                for( uint i = 0; i < num_WTess; i++ )
                {
                    string row = string("\t\t  [") + double( m_Tess_ValW[i] ) + string(",") + double( Error_Tess_theo[x][0][i] ) + 
                        string(",") + double( Error_Tess_theo[x][1][i] ) + string(",") + double( Error_Tess_theo[x][2][i] ) + string(",") + 
                        double( Error_Tess_theo[x][3][i] );

                    if ( i == num_WTess - 1 )
                    {
                        row += string("]\n");
                    }
                    else
                    {
                        row += string("],\n");
                    }
                    
                    data_str_vec2.push_back( row );
                }
                
                c2.WriteChartHead( data_str_vec2 );
                m_SweepTessIDVec.push_back( c2.m_ChartName );
                
                // Span Tess
                HTMLChart c3 = HTMLChart(); // Initialize Chart
                c3.m_ChartName = string("SpanAR") + int(2*m_halfAR[x]) + string("_Sweep35");
                c3.m_Legend = string("'Span Tesselation','20','40','60','80'");
                c3.m_Title = string("35° Sweep VLM: % Error of VSPAERO and Theoretical Cl_alpha of Various Chord Tesselation for AR = ") + int(2*m_halfAR[x]);
                c3.m_HAxisString = string("hAxis: { title: 'Span Tess', titleTextStyle: { bold: true } }");
                c3.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
                c3.m_Width = 0.38;
                
                array<string> data_str_vec3;
                for( uint i = 0; i < num_UTess; i++ )
                {
                    string row = string("\t\t  [") + double( m_Tess_ValU[i] ) + string(",") + double( Error_Tess_theo[x][i][0] ) + 
                        string(",") + double( Error_Tess_theo[x][i][1] ) + string(",") + double( Error_Tess_theo[x][i][2] ) + string(",") + 
                        double( Error_Tess_theo[x][i][3] );

                    if ( i == num_UTess - 1 )
                    {
                        row += string("]\n");
                    }
                    else
                    {
                        row += string("],\n");
                    }
                    
                    data_str_vec3.push_back( row );
                }
                
                c3.WriteChartHead( data_str_vec3 );
                m_SweepTessIDVec.push_back( c3.m_ChartName );
            }
        }
    }
    
    void SweepSweepStudy()
    {
        m_runflag = true;
        
        //====Generate Wings====//
        GenerateSweepSweepStudyWings();
        
        //====Test Wings====//
        // Testing various AR wings to study how large AR needs to be
        // to get close enough to 2D results
        TestSweepSweepStudyWings();
    }
    
    private void GenerateSweepSweepStudyWings()
    {
        //====Add Wing====//
        string wing_id = AddGeom( "WING", "" );

        //====Set Wing Section====//
        SetDriverGroup( wing_id, 1, AR_WSECT_DRIVER, ROOTC_WSECT_DRIVER, TIPC_WSECT_DRIVER );
        
        Update();

        //==== Set Airfoil to NACA0012 Airfoil and Set Common Parms ====//
        SetParmVal( wing_id, "ThickChord", "XSecCurve_0", 0.12 );
        SetParmVal( wing_id, "ThickChord", "XSecCurve_1", 0.12 );
        SetParmVal( wing_id, "Root_Chord", "XSec_1", 1 );
        SetParmVal( wing_id, "Tip_Chord", "XSec_1", 1 );
        
        Update();
        
        for ( uint8 x = 0; x < uint8(m_halfAR.length()); x++ )
        {
            for ( uint8 v = 0; v < uint8(m_Sweep.length()); v++ )
            {
                SetParmVal( wing_id, "Sweep", "XSec_1", m_Sweep[v] );
                SetParmVal( wing_id, "Aspect", "XSec_1", m_halfAR[x] );

                Update();

                //==== Setup export filenames ====//
                string fname_vavtest = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep" + int(m_Sweep[v]) + ".vsp3";

                //==== Save Vehicle to File ====//
                Print("-->Saving vehicle file to: ", false );
                Print( fname_vavtest, true );
                Print( "" );
                WriteVSPFile( fname_vavtest, SET_ALL );
                Print( "COMPLETE\n" );
            }
        }
        
        ClearVSPModel();
    }

    private void TestSweepSweepStudyWings()
    {
        Print( string( "-> Begin Sweep Sweep Test of Wings:\n" ) );

        const uint8 num_AR = uint8(m_halfAR.length());
        const uint8 num_Sweep = uint8(m_Sweep.length());
        
        array<array<double>> Lift_angle_vlm(num_AR), Lift_angle_theo(num_AR), Cl_alpha_vlm(num_AR), Cl_alpha_theo(num_AR), Lift_angle_pm(num_AR), Cl_alpha_pm(num_AR);
        array<double> Error_Vec_vlm(num_Sweep), C_ratio(num_AR), Error_Vec_pm(num_Sweep);
        
        for ( uint8 x = 0; x < num_AR; x++ )
        {
            Lift_angle_vlm[x].resize(num_Sweep);
            Lift_angle_pm[x].resize(num_Sweep);
            Lift_angle_theo[x].resize(num_Sweep);

            Cl_alpha_vlm[x].resize(num_Sweep);
            Cl_alpha_pm[x].resize(num_Sweep);
            Cl_alpha_theo[x].resize(num_Sweep);
            
            C_ratio[x] = 1/(2*m_halfAR[x]); // AR to chord ratio
            
            for ( uint8 v = 0; v < num_Sweep; v++ )
            {
                // Open the file
                string fname_tess = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep" + int(m_Sweep[v]) + ".vsp3";
                string fname_csv_vlm = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep" + int(m_Sweep[v]) + "vlm_res.csv";
                string fname_csv_pm = "NACA0012_AR" + int(2*m_halfAR[x]) + "_Sweep" + int(m_Sweep[v]) + "pm_res.csv";

                Print( string( "Reading in file: " ), false );
                Print( fname_tess );
                ReadVSPFile( fname_tess ); // Sets VSP3 file name
                
                //==== Analysis: VSPAeroSinglePoint ====//
                Print( m_VSPSingleAnalysis );

                //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                Print( m_CompGeomAnalysis );

                // Set defaults
                SetAnalysisInputDefaults( m_CompGeomAnalysis );

                // list inputs, type, and current values
                PrintAnalysisInputs( m_CompGeomAnalysis );
                
                // Execute
                Print( "\tExecuting..." );
                string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( compgeom_resid );

                //==== Analysis: VSPAero Single Point ====//
                // Set defaults
                SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                Print(m_VSPSingleAnalysis);

                // Reference geometry set
                SetIntAnalysisInput( m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0 );
                SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

                array< string > wid = FindGeomsWithName( "WingGeom" );
                SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);

                // Freestream Parameters
                Print( "\tExecuting input Parameters..." );
                array<double> Alpha(1, 1.0);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);
                SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

                Update();

                // list inputs, type, and current values
                PrintAnalysisInputs( m_VSPSingleAnalysis );
                Print( "" );

                // Execute
                Print( "\tExecuting..." );
                string rid = ExecAnalysis( m_VSPSingleAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( rid );
                WriteResultsCSVFile( rid, fname_csv_vlm );

                // Get Result ID Vec (History and Load ResultIDs)
                array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
                if ( rid_vec.length() > 0 )
                {
                    // Get History Results (rid_vec[0]) from Final Wake Iteration in History Result
                    array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                    double Cl_res = cl_vec[int(cl_vec.length()) - 1];
                    Cl_alpha_vlm[x][v] = Cl_res; // alpha = 1.0 (deg)
                    
                    // Calculate Experimental and Theoretical Values
                    double C_bot_two = 1 + (pow((tan(Deg2Rad(m_Sweep[v]))),2)/pow(b,2));
                    double C_top = 2*pi*2*m_halfAR[x];
                    
                    Lift_angle_vlm[x][v] = 1/(Cl_alpha_vlm[x][v]); // deg
                    double C_bot_one_theo = (pow((2*m_halfAR[x]),2)*pow(b,2))/pow(k_theo,2);
                    double C_bot_theo = (2 + (sqrt((C_bot_one_theo*C_bot_two)+4)));
                    double C_l_alpha_exper_theo = C_top/C_bot_theo;
                    Cl_alpha_theo[x][v] = C_l_alpha_exper_theo*(pi/180); // rad --> deg
                    Lift_angle_theo[x][v] = 1/Cl_alpha_theo[x][v]; // Cl to lift angle
                    
                    // Add error
                    Error_Vec_vlm[v] += abs(Lift_angle_vlm[x][v] - Lift_angle_theo[x][v])/abs(Lift_angle_theo[x][v]);
                }
                
                //==== Analysis: VSPAero Panel Single ====//
                Print( m_VSPSingleAnalysis );

                // Find and delete VLM MeshGeom
                array< string > mid = FindGeomsWithName( "MeshGeom" );
                DeleteGeomVec( mid );
                Update();
                
                //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                Print( m_CompGeomAnalysis );

                // Set defaults
                SetAnalysisInputDefaults( m_CompGeomAnalysis );
                
                array<int> panel_analysis(1, VSPAERO_ANALYSIS_METHOD::PANEL);
                SetIntAnalysisInput( m_CompGeomAnalysis, "AnalysisMethod", panel_analysis );

                // list inputs, type, and current values
                PrintAnalysisInputs( m_CompGeomAnalysis );

                // Execute
                Print( "\tExecuting..." );
                compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( compgeom_resid );
                
                //==== Analysis: VSPAero Panel Single ====//
               // Set defaults
                SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                Print(m_VSPSingleAnalysis);

                // Reference geometry set
                SetIntAnalysisInput(m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0);
                SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);
                SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);
                SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);
                SetIntAnalysisInput( m_VSPSingleAnalysis, "AnalysisMethod", panel_analysis );
                
                // Freestream Parameters
                Print( "\tExecuting input Parameters..." );
                array<double> alpha(1, 1);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", alpha, 0);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);

                Update();

                // list inputs, type, and current values
                PrintAnalysisInputs( m_VSPSingleAnalysis );
                Print( "" );

                // Execute
                Print( "\tExecuting..." );
                rid = ExecAnalysis( m_VSPSingleAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( rid );
                WriteResultsCSVFile( rid, fname_csv_pm );
                
                // Get Result ID Vec (History and Load ResultIDs)
                rid_vec = GetStringResults( rid, "ResultsVec" );
                
                if ( rid_vec.length() > 0 )
                {
                    // Get Result from Final Wake Iteration
                    array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                    
                    double Cl_pm = cl_vec[int(cl_vec.length()) - 1];
                    Cl_alpha_pm[x][v] = Cl_pm; // deg (alpha = 1.0°)
                    Lift_angle_pm[x][v] = 1/(Cl_alpha_pm[x][v]); // deg
                    
                    // Add error
                    Error_Vec_pm[v] += abs(Lift_angle_pm[x][v] - Lift_angle_theo[x][v])/abs(Lift_angle_theo[x][v]);
                }
                
                ClearVSPModel();
            }
        }

        for ( uint8 v = 0; v < num_Sweep; v++ )
        {
            // Sweep Sweep -- Chord Ratio vs. Lift Angle'
            HTMLChart c1 = HTMLChart(); // Initialize Chart
            c1.m_ChartName = string("Sweep") + int(m_Sweep[v]) + string("_CRvLA");
            c1.m_Legend = string("'1/AR','VSPAERO VLM','VSPAERO Panel','3D Theoretical Approx'");
            c1.m_Series = string("{ 2: { pointSize: 0, color: 'gray', lineWidth: 3 } }");
            c1.m_Title = int(m_Sweep[v]) + string("° Sweep: Lift Angle vs Chord Ratio"); 
            c1.m_HAxisString = string("hAxis: { title: '1/AR', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
            c1.m_VAxisString = string("vAxis: { title: 'd_a/d_C_l (°)', titleTextStyle: { bold: true }, viewWindow: { min: 0.0, max: 20.0 } }");
            c1.m_Width = 0.38;

            array<string> data_str_vec1;
            for( uint i = 0; i < num_AR; i++ )
            {
                string row = string("\t\t  [") + double( C_ratio[i] ) + string(",") + double( Lift_angle_vlm[i][v] ) + string(",") + 
                    double( Lift_angle_pm[i][v] ) + string(",") + double( Lift_angle_theo[i][v] );

                if ( i == num_AR - 1 )
                {
                    row += string("]\n");
                }
                else
                {
                    row += string("],\n");
                }
                
                data_str_vec1.push_back( row );
            }
            
            c1.WriteChartHead( data_str_vec1 );
            m_SweepSweepLAvCRIDVec.push_back( c1.m_ChartName );
            
            // Sweep Sweep -- Cl_alpha vs. AR
            HTMLChart c3 = HTMLChart(); // Initialize Chart
            c3.m_ChartName = string("Sweep") + int(m_Sweep[v]) + string("_CLavAR");
            c3.m_Legend = string("'AR','VSPAERO VLM','VSPAERO Panel','3D Theoretical Approx'");
            c3.m_Series = string("{ 2: { pointSize: 0, color: 'gray', lineWidth: 3 } }");
            c3.m_Title = int(m_Sweep[v]) + string("° Sweep: Cl_alpha vs. Aspect Ratio"); 
            c3.m_HAxisString = string("hAxis: { title: 'AR', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
            c3.m_VAxisString = string("vAxis: { title: 'Cl_alpha (°)', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
            c3.m_Width = 0.38;
            
            array<string> data_str_vec3;
            for( uint i = 0; i < num_AR; i++ )
            {
                string row = string("\t\t  [") + double( 2*m_halfAR[i] ) + string(",") + double( Cl_alpha_vlm[i][v] ) + string(",") + double( Cl_alpha_pm[i][v] ) + string(",") + double( Cl_alpha_theo[i][v] );

                if ( i == num_AR - 1 )
                {
                    row += string("]\n");
                }
                else
                {
                    row += string("],\n");
                }
                
                data_str_vec3.push_back( row );
            }
            
            c3.WriteChartHead( data_str_vec3 );
            m_SweepSweepClavARIDVec.push_back( c3.m_ChartName );
        }
        
        // Average % Dif of VSPAERO/Theoretical Results vs. Sweep
        HTMLChart c2 = HTMLChart(); // Initialize Chart
        c2.m_ChartName = string("ErrorvSweep");
        c2.m_Legend = string("'Sweep','Ave % VLM Error', 'Ave % Panel Error'");
        c2.m_Title = string("Average % Error in Cl_alpha of VSPAERO to Theoretical Results vs. Sweep"); 
        c2.m_HAxisString = string("hAxis: { title: 'Sweep (°)', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        c2.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        
        array<string> data_str_vec2;
        for( uint i = 0; i < num_Sweep; i++ )
        {
            string row = string("\t\t  [") + double( m_Sweep[i] ) + string(",") + double( Error_Vec_vlm[i] )+ string(",") + double( Error_Vec_pm[i] );

            if ( i == num_Sweep - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec2.push_back( row );
        }
        
        c2.WriteChartHead( data_str_vec2 );
        m_SweepSweepErrorIDVec.push_back( c2.m_ChartName );
    }
    
    // Swept Wing Class Properties
    private array<double> m_halfAR(6);
    private array<double> m_Tip_Clus(1); // Increase to 3?
    private array<int> m_Tess_ValU(4);
    private array<int> m_Tess_ValW(4);
    private array<double> m_Sweep(4);
    
    array<string> m_SweepARIDVec;
    array<string> m_SweepTessIDVec;
    array<string> m_SweepSweepLAvCRIDVec;
    array<string> m_SweepSweepClavARIDVec;
    array<string> m_SweepSweepErrorIDVec;
    
    double m_35Sweep_LA_Err;
}

//============= Bertin-Smith Study Functions ==============//
class BertinVV : VV_Base
{
    BertinVV()
    {
        m_Cl_alpha_expected = 3.433; // rad
    }
    
    void BertinSmithStudy()
    {
        m_runflag = true;
        
        //====Generate Bertin Smith Wings====//
        GenerateBertinSmithWings();

        //====Test Bertin Smith Sweep Wings Panel====//
        TestBertinSmithSweepWing();
        
        //====Test Bertin Smith Single Wing====//
        TestBertinSmithSingleWing();
    }
    
    private void GenerateBertinSmithWings()
    {
        //==== Add Wing Geometry ====//
        string wing_id = AddGeom( "WING", "" );

        //==== Set Wing Section Controls to AR, Root Chord, and Tail Chord ====//
        SetDriverGroup( wing_id, 1, AR_WSECT_DRIVER, ROOTC_WSECT_DRIVER, TIPC_WSECT_DRIVER );
        
        Update();

        //==== Set Airfoil to NACA0012 and Bertin-Smith Wing Parms ====//
        SetParmVal( wing_id, "ThickChord", "XSecCurve_0", 0.12 );
        SetParmVal( wing_id, "ThickChord", "XSecCurve_1", 0.12 );
        SetParmVal( wing_id, "Sweep_Location", "XSec_1", 0 );
        SetParmVal( wing_id, "Sweep", "XSec_1", 45 );
        SetParmVal( wing_id, "Root_Chord", "XSec_1", 0.2 );
        SetParmVal( wing_id, "Tip_Chord", "XSec_1", 0.2 );
        SetParmVal( wing_id, "Aspect", "XSec_1", 2.5 );

        Update();

        //==== Setup export filenames for VSPAERO sweep ====//
        string fname_vavtest1 = "Bertin_Smith.vsp3";

        //==== Save Vehicle to File ====//
        Print("-->Saving vehicle file to: ", false );
        Print( fname_vavtest1, true );
        Print( "" );
        WriteVSPFile( fname_vavtest1, SET_ALL );
        Print( "COMPLETE\n" );
        
        //==== Setup export filenames for VSPAERO single ====//
        string fname_vavtest2 = "Bertin_Smith_aoa1.vsp3";

        //==== Save Vehicle to File ====//
        Print("-->Saving vehicle file to: ", false );
        Print( fname_vavtest2, true );
        Print( "" );
        WriteVSPFile( fname_vavtest2, SET_ALL );
        Print( "COMPLETE\n" );

        ClearVSPModel();
    }

    private void TestBertinSmithSweepWing()
    {
        Print( string( "-> Begin Bertin-Smith Sweep Test:\n" ) );
        
        m_AlphaNpts = 8;
        const double alpha_0 = -20.0; // deg
        const double alpha_f = 20.0; // deg
        const double d_alpha = alpha_f - alpha_0; // deg

        //==== Open and test generated wing ====//
        string fname_vavtest = "Bertin_Smith.vsp3";
        string fname_csv = "Bertin_Smith_res.csv";

        Print( string( "Reading in file: " ), false );
        Print( fname_vavtest );
        ReadVSPFile( fname_vavtest ); // Sets VSP3 file name

        //==== Analysis: VSPAero Sweep ====//
        Print( m_VSPSweepAnalysis );

        //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
        Print( m_CompGeomAnalysis );

        // Set defaults
        SetAnalysisInputDefaults( m_CompGeomAnalysis );

        // list inputs, type, and current values
        PrintAnalysisInputs( m_CompGeomAnalysis );

        // Execute
        Print( "\tExecuting..." );
        string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( compgeom_resid );

        //==== Analysis: VSPAero Sweep ====//
        // Set defaults
        SetAnalysisInputDefaults(m_VSPSweepAnalysis);
        Print(m_VSPSweepAnalysis);

        // Reference geometry set
        SetIntAnalysisInput(m_VSPSweepAnalysis, "GeomSet", m_GeomVec, 0);
        SetIntAnalysisInput(m_VSPSweepAnalysis, "RefFlag", m_RefFlagVec, 0);

        array< string > wid = FindGeomsWithName( "WingGeom" );
        SetStringAnalysisInput(m_VSPSweepAnalysis, "WingID", wid, 0);
        
        SetIntAnalysisInput(m_VSPSweepAnalysis, "WakeNumIter", m_WakeIterVec, 0);

        // Freestream Parameters
        Print( "\tExecuting input Parameters..." );
        array<double> AlphaStart( 1, alpha_0 );
        array<double> AlphaEnd( 1, alpha_f );
        array<int> AlphaNpts( 1, m_AlphaNpts );
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "AlphaStart", AlphaStart, 0);
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "AlphaEnd", AlphaEnd, 0);
        SetIntAnalysisInput(m_VSPSweepAnalysis, "AlphaNpts", AlphaNpts, 0);
        array<double> MachNpts(1, 1); // Start and end at 0.1
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachStart", m_MachVec, 0);
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachEnd", m_MachVec, 0);
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachNpts", MachNpts, 0);

        Update();

        // list inputs, type, and current values
        PrintAnalysisInputs( m_VSPSweepAnalysis );
        Print( "" );

        // Execute
        Print( "\tExecuting..." );
        string rid = ExecAnalysis( m_VSPSweepAnalysis );
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( rid );
        WriteResultsCSVFile( rid, fname_csv );

        // Get Result ID Vec (History and Load ResultIDs)
        array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
        if ( rid_vec.length() <= 1 )
        {
            ClearVSPModel();
            return;
        }
            
        array<double> Cd_tot_res( m_AlphaNpts ), Cd_i_res( m_AlphaNpts ), Cl_res( m_AlphaNpts ); 
        m_Cl_alpha_error.resize( m_AlphaNpts );
        m_AlphaVec.resize( m_AlphaNpts );
        m_Cl_alpha_res.resize( m_AlphaNpts );
            
        // Get Result from Final Wake Iteration
        for ( uint i = 0; i < uint(m_AlphaNpts); i++ )
        {
            array<double> alpha_vec = GetDoubleResults( rid_vec[i], "Alpha" );
            m_AlphaVec[i] = alpha_vec[int(alpha_vec.length()) - 1];
            
            array<double> cl_vec = GetDoubleResults( rid_vec[i], "CL" );
            Cl_res[i] = cl_vec[int(cl_vec.length()) - 1];
            
            if ( m_AlphaVec[i] == 0.0 )
            {
                m_Cl_alpha_res[i] = 0.0;
            }
            else
            {
                m_Cl_alpha_res[i] = ((Cl_res[i]/m_AlphaVec[i])*(180/pi));
            }
            
            m_Cl_alpha_error[i] = (abs(m_Cl_alpha_res[i] - m_Cl_alpha_expected)/abs(m_Cl_alpha_expected))*100;
        }

        double Cl_alpha_res_avg = ((Cl_res[m_AlphaNpts - 1] - Cl_res[0])/d_alpha)*(180/pi); //rad

        m_Bertin_Sweep_Cl_alpha_Err = (abs(Cl_alpha_res_avg - m_Cl_alpha_expected)/abs(m_Cl_alpha_expected))*100;
        
        string ouput = "The error between VSPAERO alpha sweep and expected Cl_alpha results for the Bertin-Smith wing: " + double( m_Bertin_Sweep_Cl_alpha_Err ) + "\n";
        Print( ouput );
        
        ouput = "Cl_alpha for the Bertin-Smith wing: " + double( Cl_alpha_res_avg ) + "\n";
        Print( ouput );
        
        ClearVSPModel();
        
        // VLM: Cl_alpha % Error of VSPAERO/Theoretical Results vs. Alpha
        HTMLChart c1 = HTMLChart(); // Initialize Chart
        c1.m_ChartName = string("BS_ClaErrorvAlpha");
        c1.m_Legend = string("'Alpha','% Error'");
        c1.m_Title = string("VLM: % Error in Cl_alpha of VSPAERO to Theoretical Results vs. Alpha"); 
        c1.m_HAxisString = string("hAxis: { title: 'Alpha (°)', titleTextStyle: { bold: true } }");
        c1.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true } }");
        
        array<string> data_str_vec1;
        for( uint i = 0; i < uint(m_AlphaNpts); i++ )
        {
            string row = string("\t\t  [") + double( m_AlphaVec[i] ) + string(",") + double( m_Cl_alpha_error[i] );

            if ( i == uint(m_AlphaNpts) - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec1.push_back( row );
        }
        
        c1.WriteChartHead( data_str_vec1 );
        m_AlphaErrorIDVec.push_back( c1.m_ChartName );
    }

    private void TestBertinSmithSingleWing()
    {
        Print( string( "-> Begin Bertin-Smith Single Test:\n" ) );

        //==== Open and test generated wings ====//
        string fname_vavtest = "Bertin_Smith_aoa1.vsp3";
        string fname_csv = "Bertin_Smith_aoa1_res.csv";

        Print( string( "Reading in file: " ), false );
        Print( fname_vavtest );
        ReadVSPFile( fname_vavtest ); // Sets VSP3 file name

        //==== Analysis: VSPAero Single Point ====//
        Print( m_VSPSingleAnalysis );

        //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
        Print( m_CompGeomAnalysis );

        // Set defaults
        SetAnalysisInputDefaults( m_CompGeomAnalysis );

        // list inputs, type, and current values
        PrintAnalysisInputs( m_CompGeomAnalysis );

        // Execute
        Print( "\tExecuting..." );
        string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( compgeom_resid );

        //==== Analysis: VSPAero Single Point ====//
        // Set defaults
        SetAnalysisInputDefaults(m_VSPSingleAnalysis);
        Print(m_VSPSingleAnalysis);

        // Reference geometry set
        SetIntAnalysisInput(m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0);
        SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

        array< string > wid = FindGeomsWithName( "WingGeom" );
        SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);
        
        SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

        // Freestream Parameters
        Print( "\tExecuting input Parameters..." );
        array<double> Alpha(1, 1);
        SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
        SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);

        Update();

        // list inputs, type, and current values
        PrintAnalysisInputs( m_VSPSingleAnalysis );
        Print( "" );

        // Execute
        Print( "\tExecuting..." );
        string rid = ExecAnalysis(m_VSPSingleAnalysis);
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( rid );
        WriteResultsCSVFile( rid, fname_csv );

        // Get Result ID Vec (History and Load ResultIDs)
        array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
        if ( rid_vec.length() <= 1 )
        {
            ClearVSPModel();
            return;
        }
        
        // Get Result from Final Wake Iteration
        array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
        double Cl_res = cl_vec[int(cl_vec.length()) - 1];

        double Cl_alpha = Cl_res; // alpha = 1.0
        m_Cl_alpha_res_single = Cl_alpha*(180/pi); // rad

        m_Cl_alpha_error_single = (abs(m_Cl_alpha_res_single - m_Cl_alpha_expected)/abs(m_Cl_alpha_expected))*100;
        
        string ouput = "The error between VSPAERO single and expected Cl_alpha results for the Bertin-Smith wing: " + double( m_Cl_alpha_error_single ) + "\n";
        Print( ouput );
        
        ouput = "Cl_alpha for the Bertin-Smith wing: " + double( m_Cl_alpha_res_single ) + "\n";
        Print( ouput );
        
        ClearVSPModel();
    }
    
    // Bertin-Smith Class Properties
    double m_Bertin_Sweep_Cl_alpha_Err;
    double m_Cl_alpha_error_single;
    double m_Cl_alpha_res_single;
    array<string> m_AlphaErrorIDVec;
    array<double> m_AlphaVec;
    array<double> m_Cl_alpha_error;
    array<double> m_Cl_alpha_res;
    double m_Cl_alpha_expected;
    int m_AlphaNpts;
}

//============= Warren-12 Study Functions ==============//
class WarrenVV : VV_Base
{
    WarrenVV()
    {
        m_AlphaNpts = 8;
        m_Cl_alpha_expected = 2.743; // rad
        m_Cm_alpha_expected = -3.10; // rad
    }
    
    void WarrrenStudy()
    {
        m_runflag = true;
        
        //====Generate Warren-12 Wings====//
        GenerateWarrenWings();

        //====Test Warren-12 Sweep Wing====//
        TestWarrenSweepWing();
        
        //====Test Warren-12 Single Wing====//
        TestWarrenSingleWing();
    }
    
    private void GenerateWarrenWings()
    {
        //==== Add Wing Geometry ====//
        string wing_id = AddGeom( "WING", "" );

        //==== Set Wing Section Controls to AR, Root Chord, and Tail Chord ====//
        SetDriverGroup( wing_id, 1, AR_WSECT_DRIVER, ROOTC_WSECT_DRIVER, TIPC_WSECT_DRIVER );
        
        Update();

        //==== Set Airfoil to NACA 0012 and Specify Warren-12 Wing Parms ====//
        SetParmVal( wing_id, "ThickChord", "XSecCurve_0", 0.12 );
        SetParmVal( wing_id, "ThickChord", "XSecCurve_1", 0.12 );
        SetParmVal( wing_id, "Sweep_Location", "XSec_1", 0 );
        SetParmVal( wing_id, "Sweep", "XSec_1", 53.54 );
        SetParmVal( wing_id, "Root_Chord", "XSec_1", 1.5 );
        SetParmVal( wing_id, "Tip_Chord", "XSec_1", 0.5 );
        SetParmVal( wing_id, "Aspect", "XSec_1", sqrt(2) );
        
        Update();

        //==== Setup export filenames for VSPAERO sweep ====//
        string fname_vavtest1 = "Warren_12.vsp3";

        //==== Save Vehicle to File ====//
        Print("-->Saving vehicle file to: ", false );
        Print( fname_vavtest1, true );
        Print( "" );
        WriteVSPFile( fname_vavtest1, SET_ALL );
        Print( "COMPLETE\n" );
        
        //==== Setup export filenames for VSPAERO single ====//
        string fname_vavtest2 = "Warren_12_aoa1.vsp3";

        //==== Save Vehicle to File ====//
        Print("-->Saving vehicle file to: ", false );
        Print( fname_vavtest2, true );
        Print( "" );
        WriteVSPFile( fname_vavtest2, SET_ALL );
        Print( "COMPLETE\n" );

        ClearVSPModel();
    }

    private void TestWarrenSweepWing()
    {
        Print( string( "-> Begin Warren-12 Sweep Test:\n" ) );
        
        const double alpha_0 = -20.0; // deg
        const double alpha_f = 20.0; // deg
        const double d_alpha = alpha_f - alpha_0; // deg
        
        //==== Open and test generated wings ====//
        string fname_vavtest = "Warren_12.vsp3";
        string fname_csv = "Warren_12_res.csv";

        Print( string( "Reading in file: " ), false );
        Print( fname_vavtest );
        ReadVSPFile( fname_vavtest ); // Sets VSP3 file name

        //==== Analysis: VSPAero Sweep ====//
        Print( m_VSPSweepAnalysis );

        //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
        Print( m_CompGeomAnalysis );

        // Set defaults
        SetAnalysisInputDefaults( m_CompGeomAnalysis );

        // list inputs, type, and current values
        PrintAnalysisInputs( m_CompGeomAnalysis );

        // Execute
        Print( "\tExecuting..." );
        string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( compgeom_resid );

        //==== Analysis: VSPAero Sweep ====//
        // Set defaults
        SetAnalysisInputDefaults(m_VSPSweepAnalysis);
        Print(m_VSPSweepAnalysis);

        // Reference geometry set
        SetIntAnalysisInput(m_VSPSweepAnalysis, "GeomSet", m_GeomVec, 0);
        SetIntAnalysisInput(m_VSPSweepAnalysis, "RefFlag", m_RefFlagVec, 0);

        array< string > wid = FindGeomsWithName( "WingGeom" );
        SetStringAnalysisInput(m_VSPSweepAnalysis, "WingID", wid, 0);
        
        SetIntAnalysisInput(m_VSPSweepAnalysis, "WakeNumIter", m_WakeIterVec, 0);

        // Freestream Parameters
        Print( "\tExecuting input Parameters..." );
        array<double> AlphaStart( 1, alpha_0 );
        array<double> AlphaEnd( 1, alpha_f );
        array<int> AlphaNpts( 1, m_AlphaNpts );
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "AlphaStart", AlphaStart, 0);
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "AlphaEnd", AlphaEnd, 0);
        SetIntAnalysisInput(m_VSPSweepAnalysis, "AlphaNpts", AlphaNpts, 0);
        array<double> MachNpts(1, 1); // Start and end at 0.1
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachStart", m_MachVec, 0);
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachEnd", m_MachVec, 0);
        SetDoubleAnalysisInput(m_VSPSweepAnalysis, "MachNpts", MachNpts, 0);

        Update();

        // list inputs, type, and current values
        PrintAnalysisInputs( m_VSPSweepAnalysis );
        Print( "" );

        // Execute
        Print( "\tExecuting..." );
        string rid = ExecAnalysis( m_VSPSweepAnalysis );
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( rid );
        WriteResultsCSVFile( rid, fname_csv );

        // Get Result ID Vec (History and Load ResultIDs)
        array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
        if ( rid_vec.length() <= 1 )
        {
            ClearVSPModel();
            return;
        }

        array<double> Cl_res(m_AlphaNpts), Cm_res(m_AlphaNpts);
        m_AlphaVec.resize(m_AlphaNpts);
        m_Cl_alpha_error.resize(m_AlphaNpts);
        m_Cl_alpha_res.resize(m_AlphaNpts);
        m_Cm_alpha_error.resize(m_AlphaNpts);
        m_Cm_alpha_res.resize(m_AlphaNpts);

        // Get Result from Final Wake Iteration
        for ( uint i = 0; i < uint(m_AlphaNpts); i++ )
        {
            array<double> alpha_vec = GetDoubleResults( rid_vec[i], "Alpha" );
            m_AlphaVec[i] = alpha_vec[int(alpha_vec.length()) - 1];
            
            array<double> cl_vec = GetDoubleResults( rid_vec[i], "CL" );
            Cl_res[i] = cl_vec[int(cl_vec.length()) - 1];

            array<double> cmy_vec = GetDoubleResults( rid_vec[i], "CMy" );
            Cm_res[i] = cmy_vec[int(cmy_vec.length()) - 1];
            
            double Cl_alpha_res, Cm_alpha_res;
            if ( m_AlphaVec[i] == 0.0 )
            {
                m_Cl_alpha_res[i] = 0.0;
                m_Cm_alpha_res[i] = 0.0;
            }
            else
            {
                m_Cl_alpha_res[i] = ((Cl_res[i]/m_AlphaVec[i])*(180/pi));
                m_Cm_alpha_res[i] = ((Cm_res[i]/m_AlphaVec[i])*(180/pi));
            }
            
            m_Cl_alpha_error[i] = (abs(m_Cl_alpha_res[i] - m_Cl_alpha_expected)/abs(m_Cl_alpha_expected))*100;
            m_Cm_alpha_error[i] = (abs(m_Cm_alpha_res[i] - m_Cm_alpha_expected)/abs(m_Cm_alpha_expected))*100;
        }

        double Cl_alpha_res_avg = ((Cl_res[m_AlphaNpts - 1] - Cl_res[0])/d_alpha)*(180/pi); //rad
        double Cm_alpha_res_avg = ((Cm_res[m_AlphaNpts - 1] - Cm_res[0])/d_alpha)*(180/pi); //rad

        m_Warren_Sweep_Cl_alpha_Err = (abs(Cl_alpha_res_avg - m_Cl_alpha_expected)/abs(m_Cl_alpha_expected))*100;
        
        string ouput = "The error between VSPAERO alpha sweep and expected Cl_alpha results for the Warren-12 wing: " + double( m_Warren_Sweep_Cl_alpha_Err ) + "\n";
        Print( ouput );
        
        ouput = "Cl_alpha for the Warren-12 wing: " + double( Cl_alpha_res_avg ) + "\n";
        Print( ouput );
        
        m_Warren_Sweep_Cm_alpha_Err = (abs(Cm_alpha_res_avg - m_Cm_alpha_expected)/abs(m_Cm_alpha_expected))*100;
        
        ouput = "The error between VSPAERO alpha sweep and expected Cm_alpha results for the Warren-12 wing: " + double( m_Warren_Sweep_Cm_alpha_Err ) + "\n";
        Print( ouput );
        
        ouput = "Cm_alpha for the Warren-12 wing: " + double( Cm_alpha_res_avg ) + "\n";
        Print( ouput );
        
        ClearVSPModel();
        
        // VLM: Cl_alpha % Error of VSPAERO/Theoretical Results vs. Alpha
        HTMLChart c1 = HTMLChart(); // Initialize Chart
        c1.m_ChartName = string("W12_ClaErrorvAlpha");
        c1.m_Legend = string("'Alpha','% Error'");
        c1.m_Title = string("VLM: % Error in Cl_alpha of VSPAERO to Theoretical Results vs. Alpha"); 
        c1.m_HAxisString = string("hAxis: { title: 'Alpha (°)', titleTextStyle: { bold: true } }");
        c1.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true } }");
        
        array<string> data_str_vec1;
        for( uint i = 0; i < uint(m_AlphaNpts); i++ )
        {
            string row = string("\t\t  [") + double( m_AlphaVec[i] ) + string(",") + double( m_Cl_alpha_error[i] );

            if ( i == uint(m_AlphaNpts) - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec1.push_back( row );
        }
        
        c1.WriteChartHead( data_str_vec1 );
        m_AlphaErrorIDVec.push_back( c1.m_ChartName );
        
        // VLM: Cm_alpha % Error of VSPAERO/Theoretical Results vs. Alpha
        HTMLChart c2 = HTMLChart(); // Initialize Chart
        c2.m_ChartName = string("W12_CmaErrorvAlpha");
        c2.m_Legend = string("'Alpha','% Error'");
        c2.m_Title = string("VLM: % Error in Cm_alpha of VSPAERO to Theoretical Results vs. Alpha"); 
        c2.m_HAxisString = string("hAxis: { title: 'Alpha (°)', titleTextStyle: { bold: true } }");
        c2.m_VAxisString = string("vAxis: { title: '% Error', titleTextStyle: { bold: true } }");
        
        array<string> data_str_vec2;
        for( uint i = 0; i < uint(m_AlphaNpts); i++ )
        {
            string row = string("\t\t  [") + double( m_AlphaVec[i] ) + string(",") + double( m_Cm_alpha_error[i] );

            if ( i == uint(m_AlphaNpts) - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec2.push_back( row );
        }
        
        c2.WriteChartHead( data_str_vec2 );
        m_AlphaErrorIDVec.push_back( c2.m_ChartName );
    }

    private void TestWarrenSingleWing()
    {
        Print( string( "-> Begin Warren-12 Single Test:\n" ) );
        
        //==== Open and test generated wing ====//
        string fname_vavtest = "Warren_12_aoa1.vsp3";
        string fname_csv = "Warren_12_aoa1_res.csv";

        Print( string( "Reading in file: " ), false );
        Print( fname_vavtest );
        ReadVSPFile( fname_vavtest ); // Sets VSP3 file name

        //==== Analysis: VSPAEROSinglePoint ====//
        Print( m_VSPSingleAnalysis );

        //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
        Print( m_CompGeomAnalysis );

        // Set defaults
        SetAnalysisInputDefaults( m_CompGeomAnalysis );

        // list inputs, type, and current values
        PrintAnalysisInputs( m_CompGeomAnalysis );

        // Execute
        Print( "\tExecuting..." );
        string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( compgeom_resid );

        //==== Analysis: VSPAero Single Point ====//
        // Set defaults
        SetAnalysisInputDefaults(m_VSPSingleAnalysis);
        Print(m_VSPSingleAnalysis);

        // Reference geometry set
        SetIntAnalysisInput(m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0);
        SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

        array< string > wid = FindGeomsWithName( "WingGeom" );
        SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);
        
        SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

        // Freestream Parameters
        Print( "\tExecuting input Parameters..." );
        array<double> Alpha(1, 1);
        SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
        SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);

        Update();

        // list inputs, type, and current values
        PrintAnalysisInputs( m_VSPSingleAnalysis );
        Print( "" );

        // Execute
        Print( "\tExecuting..." );
        string rid = ExecAnalysis( m_VSPSingleAnalysis );
        Print( "COMPLETE" );

        // Get & Display Results
        PrintResults( rid );
        WriteResultsCSVFile( rid, fname_csv );

        // Get Result ID Vec (History and Load ResultIDs)
        array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
        if ( rid_vec.length() <= 1 )
        {
            ClearVSPModel();
            return;
        }
        
        // Get Result from Final Wake Iteration
        array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
        double Cl_res = cl_vec[int(cl_vec.length()) - 1];

        array<double> cmy_vec = GetDoubleResults( rid_vec[0], "CMy" );
        double Cm_res = cmy_vec[int(cmy_vec.length()) - 1];
        
        double Cl_alpha = Cl_res; // alpha = 1.0
        m_Cl_alpha_res_single = Cl_alpha*(180/pi); // rad
        
        double Cm_alpha = Cm_res; // alpha = 1.0
        m_Cm_alpha_res_single = Cm_alpha*(180/pi); // rad
        
        m_Cl_alpha_error_single = (abs(m_Cl_alpha_res_single - m_Cl_alpha_expected)/abs(m_Cl_alpha_expected))*100;
        
        string ouput = "The error between VSPAERO single and expected Cl_alpha results for the Warren-12 wing: " + double( m_Cl_alpha_error_single ) + "\n";
        Print( ouput );
        
        ouput = "Cl_alpha for the Warren-12 wing: " + double( m_Cl_alpha_res_single ) + "\n";
        Print( ouput );
        
        m_Cm_alpha_error_single = (abs(m_Cm_alpha_res_single - m_Cm_alpha_expected)/abs(m_Cm_alpha_expected))*100;
        
        ouput = "The error between VSPAERO single and expected Cm_alpha results for the Warren-12 wing: " + double( m_Cm_alpha_error_single ) + "\n";
        Print( ouput );
        
        ouput = "Cm_alpha for the Warren-12 wing: " + double( m_Cm_alpha_res_single ) + "\n";
        Print( ouput );
        
        ClearVSPModel();
    }
    
    // Warren-12 Class Properties
    double m_Warren_Sweep_Cl_alpha_Err;
    double m_Warren_Sweep_Cm_alpha_Err;
    double m_Cl_alpha_error_single;
    double m_Cm_alpha_error_single;
    double m_Cl_alpha_res_single;
    double m_Cm_alpha_res_single;
    array<string> m_AlphaErrorIDVec;
    array<double> m_AlphaVec;
    array<double> m_Cl_alpha_error;
    array<double> m_Cl_alpha_res;
    double m_Cl_alpha_expected;
    array<double> m_Cm_alpha_error;
    array<double> m_Cm_alpha_res;
    double m_Cm_alpha_expected;
    int m_AlphaNpts;
}

//============= VKT Study Functions ==============//
// Note: These studies can cause VSPAERO to crash, but typically not on the same run case every time. When VSPAERO crashes,
//  click "close" to skip the particular run case and continue the study. 
class VKTVV : VV_Base
{
    VKTVV()
    {
        m_epsilon[0] = 0.1;
        m_epsilon[1] = 0.2;
        
        m_kappa[0] = 0;
        m_kappa[1] = 0.1;
        
        m_tau[0] = 0;
        m_tau[1] = 10;
        
        // Add another intermediary chord and span tesselation value?
        m_ChordTess[0] = 20;
        m_ChordTess[1] = 50;
        m_ChordTess[2] = 80;
        
        m_SpanTess[0] = 20;
        m_SpanTess[1] = 60;
        m_SpanTess[2] = 100;
    }
    
    void VKTStudy()
    {
        m_runflag = true;
        
        //====Generate VKT EpsKapTau Tess Wings====//
        GenerateVKTEpsKapTauTessWings();

        //====Test VKT EpsKapTau Tess Wings====//
        TestVKTEpsKapTauTessWings();
    }

    private void GenerateVKTEpsKapTauTessWings()
    {
        //==== Add Wing Geometry and Set Common Parms ====//
        string wing_id = AddGeom( "WING", "" );
        
        // Set VKT airfoil
        string xsec_surf = GetXSecSurf( wing_id, 0 );
        ChangeXSecShape( xsec_surf, 0, XS_VKT_AIRFOIL );
        string xsec_surf1 = GetXSecSurf(wing_id, 1);
        ChangeXSecShape( xsec_surf1, 1, XS_VKT_AIRFOIL );
        
        //==== Set Wing Section Controls ====//
        SetDriverGroup( wing_id, 1, AR_WSECT_DRIVER, ROOTC_WSECT_DRIVER, TIPC_WSECT_DRIVER );
        
        Update();
        
        //==== Set Common Parms ====//
        SetParmVal( wing_id, "Sweep", "XSec_1", 0 );
        SetParmVal( wing_id, "Root_Chord", "XSec_1", 1 );
        SetParmVal( wing_id, "Tip_Chord", "XSec_1", 1 );
        
        Update();

        for ( int e = 0; e < int(m_epsilon.length()); e++ )
        {
            for ( int k = 0; k < int(m_kappa.length()); k++ )
            {
                for ( int t = 0; t < int(m_tau.length()); t++ )
                {
                    SetParmVal( wing_id, "Epsilon", "XSecCurve_0", m_epsilon[e] );
                    SetParmVal( wing_id, "Epsilon", "XSecCurve_1", m_epsilon[e] );
                    SetParmVal( wing_id, "Kappa", "XSecCurve_0", m_kappa[k] );
                    SetParmVal( wing_id, "Kappa", "XSecCurve_1", m_kappa[k] );
                    SetParmVal( wing_id, "Tau", "XSecCurve_0", m_tau[t] );
                    SetParmVal( wing_id, "Tau", "XSecCurve_1", m_tau[t] );
                    
                    SetParmVal( wing_id, "Aspect", "XSec_1", 15.0001 );
                    SetParmVal( wing_id, "Tess_W", "Shape", 70 );
                    SetParmVal( wing_id, "SectTess_U", "XSec_1", 30 );
                    SetParmVal( wing_id, "TECluster", "WingGeom", 0.65 );
                    SetParmVal( wing_id, "LECluster", "WingGeom", 0.35 );

                    Update();

                    //==== Setup export filenames for EKT Study ====//
                    string fname_ekt_test = "VKT_AR30" + "_e" + double(m_epsilon[e]) + "_k" + double(m_kappa[k]) + "_t" + double(m_tau[t]) + ".vsp3";

                    //==== Save Vehicle to File ====//
                    Print("-->Saving vehicle file to: ", false );
                    Print( fname_ekt_test, true );
                    Print( "" );
                    WriteVSPFile( fname_ekt_test, SET_ALL );
                    Print( "COMPLETE\n" );
                    
                    if ( ( m_epsilon[e] == 0.1 ) && ( m_kappa[k] == 0.1 ) && ( m_tau[t] == 10 ) )
                    {
                        SetParmVal( wing_id, "Aspect", "XSec_1", 7.5005 );
                        SetParmVal( wing_id, "TECluster", "WingGeom", 1.0 );
                        SetParmVal( wing_id, "LECluster", "WingGeom", 0.5 );
                        
                        Update();

                        for ( int c = 0; c < int(m_ChordTess.length()); c++ )
                        {
                            for ( int s = 0; s < int(m_SpanTess.length()); s++ )
                            {
                                SetParmVal( wing_id, "Tess_W", "Shape", m_ChordTess[c] );
                                SetParmVal( wing_id, "SectTess_U", "XSec_1", m_SpanTess[s] );

                                Update();

                                //==== Setup export filenames ====//
                                string fname_tess_test = "VKT_AR15" + "_e" + double(m_epsilon[e]) + "_k" + double(m_kappa[k]) + "_t" + double(m_tau[t]) + "_cTess" + 
                                    double(m_ChordTess[c]) + "_sTess" + double(m_SpanTess[s]) + ".vsp3";

                                //==== Save Vehicle to File ====//
                                Print("-->Saving vehicle file to: ", false );
                                Print( fname_tess_test, true );
                                Print( "" );
                                WriteVSPFile( fname_tess_test, SET_ALL );
                                Print( "COMPLETE\n" );
                            }
                        }
                    }
                }
            }
        }
        
        ClearVSPModel();
    }

    private void TestVKTEpsKapTauTessWings()
    {
        Print( string( "-> Begin VKT Epsilon Kappa Tau Tess Test:\n" ) );

        uint8 num_epsilon = uint8(m_epsilon.length());
        uint8 num_kappa = uint8(m_kappa.length());
        uint8 num_tau = uint8(m_tau.length());
        uint8 num_CTess = uint8(m_ChordTess.length());
        uint8 num_STess = uint8(m_SpanTess.length());
        
        array<double> cut(1, 0.0);
        const int npts_l = 122; // low point density
        
        array<array<array<array<vec3d>>>> xyz_airfoil_mat_ekt(num_epsilon); // index 0: epsilon, index 1: kappa, index 3: tau
        array<array<array<array<double>>>> cp_airfoil_mat_ekt(num_epsilon), x_slicer_mat_ekt(num_epsilon), 
            cp_slicer_mat_ekt(num_epsilon); // index 0: epsilon, index 1: kappa, index 3: tau
            
        array<vec3d> xyz_airfoil_mat_tess;
        array<double> cp_airfoil_mat_tess;
        array<array<array<double>>> x_slicer_mat_tess(num_CTess), z_slicer_mat_tess(num_CTess), cp_slicer_mat_tess(num_CTess); // index 0: CTess, index 1: STess
        
        // Load XFoil's Cp Distribution for VKT with epsilon = 0.1, kappa = 0.1, && tau = 10°
        string xfoil_file_name = string("C:\\OpenVSP\\Repo\\examples\\airfoil\\XFoil_VKT_CpDist.txt");
        array<vec3d> Xfoil_CpDist = ReadCpDistFile( xfoil_file_name );
        
        for ( uint8 e = 0; e < num_epsilon; e++ )
        {
            xyz_airfoil_mat_ekt[e].resize(num_kappa);
            cp_airfoil_mat_ekt[e].resize(num_kappa);
            x_slicer_mat_ekt[e].resize(num_kappa);
            cp_slicer_mat_ekt[e].resize(num_kappa);
            
            for ( uint8 k = 0; k < num_kappa; k++ )
            {
                xyz_airfoil_mat_ekt[e][k].resize(num_tau);
                cp_airfoil_mat_ekt[e][k].resize(num_tau);
                x_slicer_mat_ekt[e][k].resize(num_tau);
                cp_slicer_mat_ekt[e][k].resize(num_tau);
                
                for ( uint8 t = 0; t < num_tau; t++ )
                {
                    //==== Epsilon Kappa Tau Study ====//
                    
                    //==== Open and test generated wings ====//
                    string fname_ekt = "VKT_AR30" + "_e" + double(m_epsilon[e]) + "_k" + double(m_kappa[k]) + "_t" + double(m_tau[t]) + ".vsp3";
                    string fname_ekt_csv = "VKT_AR30" + "_e" + double(m_epsilon[e]) + "_k" + double(m_kappa[k]) + "_t" + double(m_tau[t]) + "_res.csv";

                    Print( string( "Reading in file: " ), false );
                    Print( fname_ekt );
                    ReadVSPFile( fname_ekt ); // Sets VSP3 file name

                    //==== Analysis: VSPAEROSinglePoint ====//
                    Print( m_VSPSingleAnalysis );

                    //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                    Print( m_CompGeomAnalysis );

                    // Set defaults
                    SetAnalysisInputDefaults( m_CompGeomAnalysis );

                    // list inputs, type, and current values
                    PrintAnalysisInputs( m_CompGeomAnalysis );

                    array<int> panel_analysis(1, VSPAERO_ANALYSIS_METHOD::PANEL);
                    SetIntAnalysisInput( m_CompGeomAnalysis, "AnalysisMethod", panel_analysis );

                    // Execute
                    Print( "\tExecuting..." );
                    string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                    Print( "COMPLETE" );

                    // Get & Display Results
                    PrintResults( compgeom_resid );

                    //==== Analysis: VSPAero Single Point ====//
                    // Set defaults
                    SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                    Print(m_VSPSingleAnalysis);

                    SetIntAnalysisInput( m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0 );
                    SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

                    array< string > wid = FindGeomsWithName( "WingGeom" );
                    SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);

                    SetIntAnalysisInput( m_VSPSingleAnalysis, "AnalysisMethod", panel_analysis );

                    // Freestream Parameters
                    Print( "\tExecuting input Parameters..." );
                    array<double> Alpha(1, 0);
                    SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
                    SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);
                    SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

                    Update();

                    // list inputs, type, and current values
                    PrintAnalysisInputs(m_VSPSingleAnalysis);
                    Print( "" );

                    // Execute
                    Print( "\tExecuting..." );
                    string rid = ExecAnalysis( m_VSPSingleAnalysis );
                    Print( "COMPLETE" );

                    // Get & Display Results
                    PrintResults( rid );
                    WriteResultsCSVFile( rid, fname_ekt_csv );
                    
                    // Calculate Analytical Solution
                    xyz_airfoil_mat_ekt[e][k][t] = GetVKTAirfoilPnts( npts_l, Alpha[0], m_epsilon[e], m_kappa[k], m_tau[t]*(pi/180) );
                    cp_airfoil_mat_ekt[e][k][t] = GetVKTAirfoilCpDist( Alpha[0], m_epsilon[e], m_kappa[k], m_tau[t]*(pi/180), xyz_airfoil_mat_ekt[e][k][t] );
                    
                    // Setup and Execute CpSlicer
                    Print( string( "\tGenerating Cp Slices...\n" ) );
                    
                    //==== Analysis: CpSlicer ====//
                    Print( m_CpSliceAnalysis );

                    // Set defaults
                    SetAnalysisInputDefaults( m_CpSliceAnalysis );
                    
                    // Setup cuts
                    SetDoubleAnalysisInput( m_CpSliceAnalysis, "YSlicePosVec", cut, 0 );

                    // list inputs, type, and current values
                    PrintAnalysisInputs( m_CpSliceAnalysis );
                    Print( "" );

                    // Execute
                    Print( "\tExecuting..." );
                    string sid = ExecAnalysis( m_CpSliceAnalysis );
                    Print( "COMPLETE" );

                    // Get & Display Results
                    PrintResults( sid );
                    Print( string( "" ) );
                    
                    array<string> rid_vec = GetStringResults( sid, "CpSlice_Case_ID_Vec" );
                    if ( rid_vec.length() >= 1 )
                    {
                        x_slicer_mat_ekt[e][k][t] = GetDoubleResults( rid_vec[0], "X_Loc" );
                        cp_slicer_mat_ekt[e][k][t] = GetDoubleResults( rid_vec[0], "Cp" );
                    }
                    
                    ClearVSPModel();
                    
                    //==== Tesselation Study ====//
                    if ( ( m_epsilon[e] == 0.1 ) && ( m_kappa[k] == 0.1 ) && ( m_tau[t] == 10 ) )
                    {
                        xyz_airfoil_mat_tess = GetVKTAirfoilPnts(npts_l, Alpha[0], m_epsilon[e], m_kappa[k], m_tau[t]*(pi/180) );
                        cp_airfoil_mat_tess = GetVKTAirfoilCpDist( Alpha[0], m_epsilon[e], m_kappa[k], m_tau[t]*(pi/180), xyz_airfoil_mat_tess );
                        
                        for ( uint8 c = 0; c < num_CTess; c++ )
                        {
                            x_slicer_mat_tess[c].resize(num_STess);
                            z_slicer_mat_tess[c].resize(num_STess);
                            cp_slicer_mat_tess[c].resize(num_STess);
                            
                            for ( uint8 s = 0; s < num_STess; s++ )
                            {
                                //==== Open and test generated wings ====//
                                // Note: *.csv result file name can not be the same as *.vsp3 file name
                                string fname_tess = "VKT_AR15" + "_e" + double(m_epsilon[e]) + "_k" + double(m_kappa[k]) + "_t" + double(m_tau[t]) + "_cTess" + 
                                    double(m_ChordTess[c]) + "_sTess" + double(m_SpanTess[s]) + ".vsp3";
                                string fname_tess_csv = "VKT_AR15" + "_e" + double(m_epsilon[e]) + "_k" + double(m_kappa[k]) + "_t" + double(m_tau[t]) + "_cTess" + 
                                    double(m_ChordTess[c]) + "_sTess" + double(m_SpanTess[s]) + "_res.csv";

                                Print( string( "Reading in file: " ), false );
                                Print( fname_tess );
                                ReadVSPFile( fname_tess ); // Sets VSP3 file name

                                //==== Analysis: VSPAEROSinglePoint ====//
                                Print( m_VSPSingleAnalysis );

                                //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                                Print( m_CompGeomAnalysis );

                                // Set defaults
                                SetAnalysisInputDefaults( m_CompGeomAnalysis );

                                // list inputs, type, and current values
                                PrintAnalysisInputs( m_CompGeomAnalysis );

                                SetIntAnalysisInput( m_CompGeomAnalysis, "AnalysisMethod", panel_analysis );

                                // Execute
                                Print( "\tExecuting..." );
                                compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                                Print( "COMPLETE" );

                                // Get & Display Results
                                PrintResults( compgeom_resid );

                                //==== Analysis: VSPAero Single Point ====//
                                // Set defaults
                                SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                                Print(m_VSPSingleAnalysis);

                                SetIntAnalysisInput( m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0 );

                                SetIntAnalysisInput( m_VSPSingleAnalysis, "AnalysisMethod", panel_analysis );

                                // Freestream Parameters
                                Print( "\tExecuting input Parameters..." );
                                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
                                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);
                                SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);

                                Update();

                                // list inputs, type, and current values
                                PrintAnalysisInputs( m_VSPSingleAnalysis );
                                Print( "" );

                                // Execute
                                Print( "\tExecuting..." );
                                rid = ExecAnalysis( m_VSPSingleAnalysis );
                                Print( "COMPLETE" );

                                // Get & Display Results
                                PrintResults( rid );
                                WriteResultsCSVFile( rid, fname_tess_csv );
                                
                                // Calculate Analytical Solution
                                
                                // Setup and Execute CpSlicer
                                Print( string( "\tGenerating Cp Slices...\n" ) );
                                
                                //==== Analysis: CpSlicer ====//
                                Print( m_CpSliceAnalysis );

                                // Set defaults
                                SetAnalysisInputDefaults( m_CpSliceAnalysis );
                                
                                // Setup cuts
                                SetDoubleAnalysisInput( m_CpSliceAnalysis, "YSlicePosVec", cut, 0 );

                                // list inputs, type, and current values
                                PrintAnalysisInputs( m_CpSliceAnalysis );
                                Print( "" );

                                // Execute
                                Print( "\tExecuting..." );
                                sid = ExecAnalysis( m_CpSliceAnalysis );
                                Print( "COMPLETE" );

                                // Get & Display Results
                                PrintResults( sid );
                                Print( string( "" ) );
                                
                                rid_vec = GetStringResults( sid, "CpSlice_Case_ID_Vec" );
                                if ( rid_vec.size() > 0 )
                                {
                                    x_slicer_mat_tess[c][s] = GetDoubleResults( rid_vec[0], "X_Loc" );
                                    z_slicer_mat_tess[c][s] = GetDoubleResults( rid_vec[0], "Z_Loc" );
                                    cp_slicer_mat_tess[c][s] = GetDoubleResults( rid_vec[0], "Cp" );
                                }

                                ClearVSPModel();
                            }
                        }
                    }
                }
            }
        }
        
        for ( uint8 e = 0; e < num_epsilon; e++ )
        {
            for ( uint8 k = 0; k < num_kappa; k++ )
            {
                for ( uint8 t = 0; t < num_tau; t++ )
                {
                    // Panel: C_P distribution of Karman-Trefftz Airfoil for Epsilon Kappa Tau Study:
                    if ( cp_slicer_mat_ekt[e][k][t].length() != 0 && cp_airfoil_mat_ekt[e][k][t].length() != 0 )
                    {
                        // Note: int k used for kappa and epsilon in chart name, since decimal values not supported in names
                        array<string> data_str_vec1;
                        
                        // Google Charts API only supports a single X data vector. The x data from GetVKTAirfoilData and the CpSlicer are different, so must be offset
                        for( uint x = 0; x < xyz_airfoil_mat_ekt[e][k][t].length(); x++ )
                        {
                            string row = string("\t\t  [") + double( xyz_airfoil_mat_ekt[e][k][t][x][0] ) + string(",") + double( xyz_airfoil_mat_ekt[e][k][t][x][1] ) +
                                string(",") + double( cp_airfoil_mat_ekt[e][k][t][x] ) + string(",null],\n");
                            
                            data_str_vec1.push_back( row );
                        }
                        
                        for( uint x = 0; x < x_slicer_mat_ekt[e][k][t].length(); x++ )
                        {
                            string row = string("\t\t  [") + double( x_slicer_mat_ekt[e][k][t][x] ) + string(",null,null,") + double( cp_slicer_mat_ekt[e][k][t][x] );
                            
                            if ( x == x_slicer_mat_ekt[e][k][t].length() - 1 )
                            {
                                row += string("]\n");
                            }
                            else
                            {
                                row += string("],\n");
                            }
                            
                            data_str_vec1.push_back( row );
                        }
                        
                        HTMLChart c1 = HTMLChart();
                        c1.m_ChartName = string("Cp_Epsilon") + int(e) + string("_Kappa") + int(k) + string("_Tau") + double(m_tau[t]);
                        c1.m_Title = string("VKT Cp Distribution at Y = 0, Epsilon = ") + double(m_epsilon[e]) + string(" Kappa = ") + 
                            double(m_kappa[k]) + string(" Tau = ") + double(m_tau[t]) + string("°");
                        c1.m_Legend = string("'X','Airfoil','Exact Solution','VSPAERO'");
                        c1.m_Series = string("{ 0: { targetAxisIndex: 1, lineWidth: 0 }, 1: { targetAxisIndex: 0, pointSize: 0, color: 'gray', lineWidth: 4 }, 2: { targetAxisIndex: 0} }");
                        c1.m_LegendPos = string("bottom");
                        c1.m_HAxisString = string("hAxis: { title: 'X', titleTextStyle: { bold: true } }");
                        c1.m_VAxisString = string("vAxes: { 0: { title: 'Cp', titleTextStyle: { bold: true } }, 1: { title: 'Z', titleTextStyle: { bold: true } } }");
                        
                        c1.WriteChartHead( data_str_vec1 );
                        m_VKTEpsKapTauIDVec.push_back( c1.m_ChartName );
                    }
                    
                    if ( ( m_epsilon[e] == 0.1 ) && ( m_kappa[k] == 0.1 ) && ( m_tau[t] == 10 ) )
                    {
                        // Panel: C_P distribution of Karman-Trefftz Airfoil Tess Study:
                        for ( uint8 c = 0; c < num_CTess; c++ )
                        {
                            for ( uint8 s = 0; s < num_STess; s++ )
                            {
                                if ( cp_slicer_mat_tess[c][s].length() != 0 && cp_airfoil_mat_tess.length() != 0 && Xfoil_CpDist.length() != 0 )
                                {
                                    // Note: int k used for kappa in chart name, since decimal values not supported in names
                                    array<string> data_str_vec2;
                                    
                                    // Google Charts API only supports a single X data vector. The x data from GetVKTAirfoilData and the CpSlicer are different, so must be offset
                                    for( uint x = 0; x < xyz_airfoil_mat_tess.length(); x++ )
                                    {
                                        string row = string("\t\t  [") + double( xyz_airfoil_mat_tess[x][0] ) + string(",") + 
                                        double( xyz_airfoil_mat_tess[x][1] ) + string(",") + double( cp_airfoil_mat_tess[x] ) + 
                                        string(",null,") + double(Xfoil_CpDist[x][2]) + string("],\n");
                                        
                                        data_str_vec2.push_back( row );
                                    }
                                    
                                    for( uint x = 0; x < x_slicer_mat_tess[c][s].length(); x++ )
                                    {
                                        string row = string("\t\t  [") + double( x_slicer_mat_tess[c][s][x] ) + string(",null,null,") + 
                                        double( cp_slicer_mat_tess[c][s][x] )+ string(",null") ;
                                        
                                        if ( x == x_slicer_mat_tess[c][s].length() - 1 )
                                        {
                                            row += string("]\n");
                                        }
                                        else
                                        {
                                            row += string("],\n");
                                        }
                                        
                                        data_str_vec2.push_back( row );
                                    }
                                    
                                    HTMLChart c2 = HTMLChart();
                                    c2.m_ChartName = string("Cp_Kappa") + int(k) + string("_W") + int(m_ChordTess[c]) + string("_U") + int(m_SpanTess[s]);
                                    c2.m_Title = string("VKT Cp distribution at Y = 0, Kappa = ") + double(m_kappa[k]) + string(" N-Chord = ") + int(m_ChordTess[c]) + 
                                        string(" N-Span = ") + int(m_SpanTess[s]);
                                    c2.m_Legend = string("'X','Airfoil','Exact Solution','VSPAERO','XFoil'");
                                    c2.m_PointSize = 3.0;
                                    c2.m_Series = string("{ 0: { targetAxisIndex: 1, lineWidth: 0 }, 1: { targetAxisIndex: 0, pointSize: 0, color: 'gray', lineWidth: 4 }, 2: { targetAxisIndex: 0 }, 3: { targetAxisIndex: 0 } }");
                                    c2.m_LegendPos = string("bottom");
                                    c2.m_HAxisString = string("hAxis: { title: 'X', titleTextStyle: { bold: true } }");
                                    c2.m_VAxisString = string("vAxes: { 0: { title: 'Cp', titleTextStyle: { bold: true } }, 1: { title: 'Z', titleTextStyle: { bold: true } } }");
                                    
                                    c2.WriteChartHead( data_str_vec2 );
                                    m_VKTTessIDVec.push_back( c2.m_ChartName );
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    // VTK Epsilon Kappa Tau Class Properties
    //=== Wing Parameters ===//
    private array<double> m_epsilon(2); // thickness
    private array<double> m_kappa(2); 
    private array<double> m_tau(2); // deg 
    private array<double> m_ChordTess(3);
    private array<double> m_SpanTess(3);
    
    array<string> m_VKTEpsKapTauIDVec;
    array<string> m_VKTTessIDVec;
}

//============= Ellipsoid Study Functions ==============//
class EllipsoidVV : VV_Base
{
    EllipsoidVV()
    {
        m_alpha_vec[0] = 0.0;
        m_alpha_vec[1] = 5.0;
        
        m_beta_vec[0] = 0.0;
        m_beta_vec[1] = 5.0;
    }
    
    void EllipsoidStudy()
    {
        m_runflag = true;
        
        //====Generate Ellipsoids====//
        // Generate ellispoids of various orientation to test //
        GenerateEllipsoids();

        //====Test Ellipsoids====//
        TestEllipsoids();
    }

    private void GenerateEllipsoids()
    {
        //==== One Ellipsoid Geom, Different File Names for Flow Conditions ====//
        string geom_id = AddGeom( "ELLIPSOID", "" );

        SetParmVal( geom_id, "X_Rel_Location", "XForm", -1.0 );
        SetParmVal( geom_id, "A_Radius", "Design", 1.0 );
        SetParmVal( geom_id, "B_Radius", "Design", 2.0 );
        SetParmVal( geom_id, "C_Radius", "Design", 3.0 );
        SetParmVal( geom_id, "Tess_U", "Shape", 40 );
        SetParmVal( geom_id, "Tess_W", "Shape", 61 );

        Update();

        for ( uint8 a = 0; a < uint8(m_alpha_vec.length()); a++ )
        {
            for ( uint8 b = 0; b < uint8(m_beta_vec.length()); b++ )
            {
                //==== Setup export filenames ====//
                string fname_ell = "Ellipsoid_alpha" + double(m_alpha_vec[a]) + "_beta" + double(m_beta_vec[b]) + ".vsp3";

                //==== Save Vehicle to File ====//
                Print("-->Saving vehicle file to: ", false );
                Print( fname_ell, true );
                Print( "" );
                WriteVSPFile( fname_ell, SET_ALL );
                Print( "COMPLETE\n" );
            }
        }
        
        ClearVSPModel();
    }

    private void TestEllipsoids()
    {
        Print( string( "-> Begin Ellipsoid Test:\n" ) );
        
        uint8 num_alpha = uint8(m_alpha_vec.length());
        uint8 num_beta = uint8(m_beta_vec.length());
        
        vec3d center = vec3d(0.0, 0.0, 0.0);
        vec3d abc_rad = vec3d(1.0, 2.0, 3.0);
        vec3d Vinf = vec3d(100.0, 0.0, 0.0);
        
        // npts defined by tesselation
        const int u_npts = 40;
        const int w_npts = 41;
        
        // Setup cuts
        array<double> cut(1, 0.0);
        
        array<array<array<array<double>>>> cp_slicer_mat(num_alpha);
        array<array<array<array<double>>>> xyz_slicer_mat(num_alpha);
        
        // Calculate Theoretical Results
        array<vec3d> ellispoid_pnt_mat, ellispoid_cp_mat;
        
        ellispoid_pnt_mat = GetEllipsoidSurfPnts(center, abc_rad, u_npts, w_npts);
        ellispoid_cp_mat = GetEllipsoidCpDist(ellispoid_pnt_mat, abc_rad, Vinf);
        
        for ( uint8 a = 0; a < num_alpha; a++ )
        {
            cp_slicer_mat[a].resize(num_beta);
            xyz_slicer_mat[a].resize(num_beta);
            
            for ( uint8 b = 0; b < num_beta; b++ )
            {
                xyz_slicer_mat[a][b].resize(3);
                cp_slicer_mat[a][b].resize(3);
                
                //==== Open and test generated ellipsoids ====//
                string fname_ell = "Ellipsoid_alpha" + double(m_alpha_vec[a]) + "_beta" + double(m_beta_vec[b]) + ".vsp3";
                string fname_csv = "Ellipsoid_alpha" + double(m_alpha_vec[a]) + "_beta" + double(m_beta_vec[b]) + "_res.csv";
                
                //==== Open and test generated wings ====//
                Print( string( "Reading in file: " ), false );
                Print( fname_ell );
                ReadVSPFile( fname_ell ); // Sets VSP3 file name

                //==== Analysis: VSPAEROSinglePoint ====//
                Print( m_VSPSingleAnalysis );

                //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                Print( m_CompGeomAnalysis );

                // Set defaults
                SetAnalysisInputDefaults( m_CompGeomAnalysis );

                // list inputs, type, and current values
                PrintAnalysisInputs( m_CompGeomAnalysis );

                array<int> panel_analysis(1,VSPAERO_ANALYSIS_METHOD::PANEL );
                SetIntAnalysisInput( m_CompGeomAnalysis, "AnalysisMethod", panel_analysis );

                // Execute
                Print( "\tExecuting..." );
                string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( compgeom_resid );

                //==== Analysis: VSPAero Single Point ====//
                // Set defaults
                SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                Print(m_VSPSingleAnalysis);

                // Reference geometry set
                SetIntAnalysisInput( m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0 );

                SetIntAnalysisInput( m_VSPSingleAnalysis, "AnalysisMethod", panel_analysis );

                // Freestream Parameters
                Print( "\tExecuting input Parameters..." );
                array<double> Alpha(1, m_alpha_vec[a]);
                array<double> Beta(1, m_beta_vec[b]);
                //array<int> Symmetry(1,1);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Beta", Beta, 0);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", m_MachVec, 0);
                SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);
                //SetIntAnalysisInput(m_VSPSingleAnalysis, "Symmetry", Symmetry, 0);

                Update();

                // list inputs, type, and current values
                PrintAnalysisInputs( m_VSPSingleAnalysis );
                Print( "" );

                // Execute
                Print( "\tExecuting..." );
                string rid = ExecAnalysis( m_VSPSingleAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( rid );
                WriteResultsCSVFile( rid, fname_csv );
                
                // Setup and Execute CpSlicer
                Print( string( "\tGenerating Cp Slices...\n" ) );
                
                //==== Analysis: CpSlicer ====//
                Print( m_CpSliceAnalysis );

                // Set defaults
                SetAnalysisInputDefaults( m_CpSliceAnalysis );
                
                // Set cuts
                SetDoubleAnalysisInput( m_CpSliceAnalysis, "XSlicePosVec", cut, 0 );
                SetDoubleAnalysisInput( m_CpSliceAnalysis, "YSlicePosVec", cut, 0 );
                SetDoubleAnalysisInput( m_CpSliceAnalysis, "ZSlicePosVec", cut, 0 );

                // list inputs, type, and current values
                PrintAnalysisInputs( m_CpSliceAnalysis );
                Print( "" );

                // Execute
                Print( "\tExecuting..." );
                string sid = ExecAnalysis( m_CpSliceAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( sid );
                Print( string( "" ) );

                array<string> rid_vec = GetStringResults( sid, "CpSlice_Case_ID_Vec" );

                if ( rid_vec.length() > 0 )
                {
                    // X Cut
                    xyz_slicer_mat[a][b][0] = GetDoubleResults( rid_vec[0], "Y_Loc" );
                    cp_slicer_mat[a][b][0] =  GetDoubleResults( rid_vec[0], "Cp" );
                    
                    // Y Cut
                    xyz_slicer_mat[a][b][1] = GetDoubleResults( rid_vec[1], "X_Loc" );
                    cp_slicer_mat[a][b][1] =  GetDoubleResults( rid_vec[1], "Cp" );

                    // Z Cut
                    xyz_slicer_mat[a][b][2] = GetDoubleResults( rid_vec[2], "X_Loc" );
                    cp_slicer_mat[a][b][2] =  GetDoubleResults( rid_vec[2], "Cp" );
                }
                
                ClearVSPModel();
            }
        }
        
        uint8 run_cnt = 1;

        for ( uint8 a = 0; a < num_alpha; a++ )
        {
            for ( uint8 b = 0; b < num_beta; b++ )
            {
                if ( ellispoid_cp_mat.length() != 0 && cp_slicer_mat[a][b][0].length() != 0 )
                {
                    // X Cut
                    array<string> data_str_vec1;

                    //Google Charts API only supports a single X data vector. The x data from GetEllipsoidSurfPnts and the CpSlicer are different, so must be offset
                    for( uint x = 0; x < uint(ellispoid_pnt_mat.length()); x++ )
                    {
                        if ( abs(ellispoid_pnt_mat[x][0]) < 0.0425 ) // x ~= 0
                        {
                            string row = string("\t\t  [") + double( ellispoid_pnt_mat[x][1] ) + string(",") + double( ellispoid_pnt_mat[x][2] ) +
                                string(",") + double( ellispoid_cp_mat[x][0] ) + string(",null],\n");
                            
                            data_str_vec1.push_back( row );
                        }
                    }
                    
                    for( uint x = 0; x < uint(xyz_slicer_mat[a][b][0].length()); x++ )
                    {
                        string row = string("\t\t  [") + double( xyz_slicer_mat[a][b][0][x] ) + string(",null") +
                            string(",null,") + double( cp_slicer_mat[a][b][0][x] );
                        
                        if ( x == xyz_slicer_mat[a][b][0].length() - 1 )
                        {
                            row += string("]\n");
                        }
                        else
                        {
                            row += string("],\n");
                        }
                        
                        data_str_vec1.push_back( row );
                    }
                    
                    HTMLChart c1 = HTMLChart();
                    c1.m_ChartName = string("Cp_ellipse_alpha") + double(m_alpha_vec[a]) + string("_beta") + double(m_beta_vec[b]) + string("_X");
                    c1.m_Title = string("Run #") + run_cnt + string(": Ellipsoid Cp Distribution at X = 0, Alpha = ") + double(m_alpha_vec[a]) + string("° Beta = ") + 
                        double(m_beta_vec[b]) + string("°");
                    c1.m_Legend = string("'X','Ellipsoid','Exact Solution','VSPAERO'");
                    c1.m_PointSize = 3.0;
                    c1.m_Series = string("{ 0: { targetAxisIndex: 1, lineWidth: 0 }, 1: { targetAxisIndex: 0, pointSize: 0, color: 'gray', lineWidth: 3 }, 2: { targetAxisIndex: 0 } }");
                    c1.m_LegendPos = string("bottom");
                    c1.m_HAxisString = string("hAxis: { title: 'Y', titleTextStyle: { bold: true }, viewWindow: { min: -3.0, max: 3.0 } }");
                    c1.m_VAxisString = string("vAxes: { 0: { title: 'Cp', titleTextStyle: { bold: true }, viewWindow: { min: -5.0, max: 0.0 } }, 1: { title: 'Z', titleTextStyle: { bold: true }, viewWindow: { min: -3.0, max: 3.0 } } }");
                    
                    c1.WriteChartHead( data_str_vec1 );
                    m_EllispoidIDVec.push_back( c1.m_ChartName );
                    
                    // Y Cut
                    array<string> data_str_vec2;
                    
                    //Google Charts API only supports a single X data vector. The x data from GetEllipsoidSurfPnts and the CpSlicer are different, so must be offset
                    for( uint x = 0; x < uint(ellispoid_pnt_mat.length()); x++ )
                    {
                        if ( abs(ellispoid_pnt_mat[x][1]) < 0.2 ) // y ~= 0
                        {
                            string row = string("\t\t  [") + double( ellispoid_pnt_mat[x][0] ) + string(",") + + double( ellispoid_pnt_mat[x][2] ) +
                                string(",") + double( ellispoid_cp_mat[x][0] ) + string(",null],\n");
                            
                            data_str_vec2.push_back( row );
                        }
                    }
                    
                    for( uint x = 0; x < uint(xyz_slicer_mat[a][b][1].length()); x++ )
                    {
                        string row = string("\t\t  [") + double( xyz_slicer_mat[a][b][1][x] ) + string(",null") +
                            string(",null,") + double( cp_slicer_mat[a][b][1][x] );
                        
                        if ( x == xyz_slicer_mat[a][b][1].length() - 1 )
                        {
                            row += string("]\n");
                        }
                        else
                        {
                            row += string("],\n");
                        }
                        
                        data_str_vec2.push_back( row );
                    }
                    
                    HTMLChart c2 = HTMLChart();
                    c2.m_ChartName = string("Cp_ellipse_alpha") + double(m_alpha_vec[a]) + string("_beta") + double(m_beta_vec[b]) + string("_Y");
                    c2.m_Title = string("Run #") + run_cnt + string(": Ellipsoid Cp Distribution at Y = 0, Alpha = ") + double(m_alpha_vec[a]) + string("° Beta = ") + 
                        double(m_beta_vec[b]) + string("°");
                    c2.m_Legend = string("'X','Ellipsoid','Exact Solution','VSPAERO'");
                    c2.m_PointSize = 3.0;
                    c2.m_Series = string("{ 0: { targetAxisIndex: 1, lineWidth: 0 }, 1: { targetAxisIndex: 0, pointSize: 0, color: 'gray', lineWidth: 3 }, 2: { targetAxisIndex: 0 } }");
                    c2.m_LegendPos = string("bottom");
                    c2.m_HAxisString = string("hAxis: { title: 'X', titleTextStyle: { bold: true }, viewWindow: { min: -3.0, max: 3.0 } }");
                    c2.m_VAxisString = string("vAxes: { 0: { title: 'Cp', titleTextStyle: { bold: true } }, 1: { title: 'Z', titleTextStyle: { bold: true }, viewWindow: { min: -3.0, max: 3.0 } } }");
                    
                    c2.WriteChartHead( data_str_vec2 );
                    m_EllispoidIDVec.push_back( c2.m_ChartName );

                    // Z Cut
                    array<string> data_str_vec3;
                    
                    for( uint x = 0; x < uint(ellispoid_pnt_mat.length()); x++ )
                    {
                        if ( abs( ellispoid_pnt_mat[x][2] ) < 0.1 ) // z ~= 0
                        {
                            string row = string("\t\t  [") + double( ellispoid_pnt_mat[x][0] ) + string(",") + double( ellispoid_pnt_mat[x][1] ) +
                                string(",") + double( ellispoid_cp_mat[x][0] ) + string(",null],\n");
                            
                            data_str_vec3.push_back(row);
                        }
                    }
                    
                    for( uint x = 0; x < uint(xyz_slicer_mat[a][b][2].length()); x++ )
                    {
                        string row = string("\t\t  [") + double( xyz_slicer_mat[a][b][2][x] ) + string(",null") +
                            string(",null,") + double( cp_slicer_mat[a][b][2][x] );
                        
                        if ( x == xyz_slicer_mat[a][b][2].length() - 1 )
                        {
                            row += string("]\n");
                        }
                        else
                        {
                            row += string("],\n");
                        }
                        
                        data_str_vec3.push_back(row);
                    }
                    
                    HTMLChart c3 = HTMLChart();
                    c3.m_ChartName = string("Cp_ellipse_alpha") + double(m_alpha_vec[a]) + string("_beta") + double(m_beta_vec[b]) + string("_Z");
                    c3.m_Title = string("Run #") + run_cnt + string(": Ellipsoid Cp Distribution at Z = 0, Alpha = ") + double(m_alpha_vec[a]) + string("° Beta = ") + 
                        double(m_beta_vec[b]) + string("°");
                    c3.m_Legend = string("'X','Ellipsoid','Exact Solution','VSPAERO'");
                    c3.m_PointSize = 3.0;
                    c3.m_Series = string("{ 0: { targetAxisIndex: 1 }, 1: { targetAxisIndex: 0, pointSize: 0, color: 'gray', lineWidth: 3 }, 2: { targetAxisIndex: 0 } }");
                    c3.m_LegendPos = string("bottom");
                    c3.m_HAxisString = string("hAxis: { title: 'X', titleTextStyle: { bold: true }, viewWindow: { min: -3.0, max: 3.0 } }");
                    c3.m_VAxisString = string("vAxes: { 0: { title: 'Cp', titleTextStyle: { bold: true } }, 1: { title: 'Y', titleTextStyle: { bold: true }, viewWindow: { min: -3.0, max: 3.0 } } }");
                    
                    c3.WriteChartHead( data_str_vec3 );
                    m_EllispoidIDVec.push_back( c3.m_ChartName );
                    
                    run_cnt++;
                }
            }
        }
    }
    
    // Ellipsoid Class Properties
    // Flow Condition Parameters
    private array<double> m_alpha_vec(2);
    private array<double> m_beta_vec(2);
    
    array<string> m_EllispoidIDVec;
}

//============= Supersonic Delta Wing Study Functions ==============//
class SDVV : VV_Base
{
    SDVV()
    {
        m_Sweep[0] = 35;
        m_Sweep[1] = 65;
        
        m_SuperMachVec[0] = 1.135;
        m_SuperMachVec[1] = 1.366;
        m_SuperMachVec[2] = 1.894;
        m_SuperMachVec[3] = 2.386; // Note m_SuperMachVec[3] = 2.366 will cause VSPAERO to crash for the 65° swept delta wing;
        m_SuperMachVec[4] = 2.861;
        m_SuperMachVec[5] = 3.369;
        m_SuperMachVec[6] = 3.884;
        m_SuperMachVec[7] = 4.404;
    }
    
    void TestSupersonicDeltaWing()
    {
        m_runflag = true;
        
        //====Generate Supersonic Delta Wings====//
        GenerateSupersonicDeltaWings();
        
        //====Test Supersonic Delta Wings====//
        TestSupersonicDeltaWings();
    }

    private void GenerateSupersonicDeltaWings()
    {
        //==== Add Wing ====//
        string wing_id = AddGeom( "WING", "" );

        //==== Set Wing Section ====//
        SetDriverGroup( wing_id, 1, SPAN_WSECT_DRIVER, ROOTC_WSECT_DRIVER, SECSWEEP_WSECT_DRIVER );
        
        Update();

        //==== Set Airfoil to NACA 0012 Airfoil and Set Common Parms====//
        SetParmVal( wing_id, "ThickChord", "XSecCurve_0", 0.12 );
        SetParmVal( wing_id, "ThickChord", "XSecCurve_1", 0.12 );
        SetParmVal( wing_id, "Sweep_Location", "XSec_1", 0 );
        SetParmVal( wing_id, "Sec_Sweep_Location", "XSec_1", 1 );
        SetParmVal( wing_id, "Sec_Sweep", "XSec_1", 0 );
        SetParmVal( wing_id, "Root_Chord", "XSec_1", 8 );
        
        Update();
        
        for ( uint8 s = 0; s < uint8(m_Sweep.length()); s++ )
        {
            SetParmVal( wing_id, "Sweep", "XSec_1", m_Sweep[s] );
            
            if (m_Sweep[s] == 35)
            {
                SetParmVal( wing_id, "Span", "XSec_1", 10 );
            }
            else if (m_Sweep[s] == 65)
            {
                SetParmVal( wing_id, "Span", "XSec_1", 3.5 );
            }

            Update();
            
            for ( uint8 m = 0; m < uint8(m_SuperMachVec.length()); m++ )
            {
                //==== Setup export filenames ====//
                string fname = "Supersonic_Delta_Wing_Sweep" + int(m_Sweep[s]) + string("_Mach") + int(m) + ".vsp3";

                //==== Save Vehicle to File ====//
                Print("-->Saving vehicle file to: ", false );
                Print( fname, true );
                Print( "" );
                WriteVSPFile( fname, SET_ALL );
                Print( "COMPLETE\n" );
            }
        }
        
        ClearVSPModel();
    }

    private void TestSupersonicDeltaWings()
    {
        Print( string( "-> Begin Supersonic Delta Wing Test:\n" ) );

        uint8 num_sweep = uint8(m_Sweep.length());
        uint8 num_mach = uint8(m_SuperMachVec.length());
        
        array<array<double>> Cl_alpha_tan_sweep(num_sweep), M_sweep_fun(num_sweep);
        
        for ( uint8 s = 0; s < num_sweep; s++ )
        {
            Cl_alpha_tan_sweep[s].resize(num_mach);
            M_sweep_fun[s].resize(num_mach);
            
            for ( uint8 m = 0; m < num_mach; m++ )
            {
                //==== Open and test generated wings ====//
                string fname = "Supersonic_Delta_Wing_Sweep" + int(m_Sweep[s]) + string("_Mach") + int(m) + ".vsp3";
                string fname_csv = "Supersonic_Delta_Wing_Sweep" + int(m_Sweep[s]) + string("_Mach") + int(m) + "_res.csv";

                Print( string( "Reading in file: " ), false );
                Print( fname );
                ReadVSPFile( fname ); // Sets VSP3 file name

                //==== Analysis: VSPAero SinglePoint ====//
                Print( m_VSPSingleAnalysis );

                //==== Analysis: VSPAero Compute Geometry to Create Vortex Lattice DegenGeom File ====//
                Print( m_CompGeomAnalysis );

                // Set defaults
                SetAnalysisInputDefaults( m_CompGeomAnalysis );

                // list inputs, type, and current values
                PrintAnalysisInputs( m_CompGeomAnalysis );

                // Execute
                Print( "\tExecuting..." );
                string compgeom_resid = ExecAnalysis( m_CompGeomAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( compgeom_resid );

                //==== Analysis: VSPAero Single Point ====//
                // Set defaults
                SetAnalysisInputDefaults(m_VSPSingleAnalysis);
                Print(m_VSPSingleAnalysis);

                // Reference geometry set
                SetIntAnalysisInput( m_VSPSingleAnalysis, "GeomSet", m_GeomVec, 0 );
                SetIntAnalysisInput(m_VSPSingleAnalysis, "RefFlag", m_RefFlagVec, 0);

                array< string > wid = FindGeomsWithName( "WingGeom" );
                SetStringAnalysisInput(m_VSPSingleAnalysis, "WingID", wid, 0);

                // Freestream Parameters
                Print( "\tExecuting input Parameters..." );
                array<double> Alpha( 1, 1 );
                array<double> Mach( 1, m_SuperMachVec[m] );
                //array<int> Symmetry(1,1);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Alpha", Alpha, 0);
                SetDoubleAnalysisInput(m_VSPSingleAnalysis, "Mach", Mach, 0);
                SetIntAnalysisInput(m_VSPSingleAnalysis, "WakeNumIter", m_WakeIterVec, 0);
                //SetIntAnalysisInput(m_VSPSingleAnalysis, "Symmetry", Symmetry, 0);

                Update();

                // list inputs, type, and current values
                PrintAnalysisInputs( m_VSPSingleAnalysis );
                Print( "" );

                // Execute
                Print( "\tExecuting..." );
                string rid = ExecAnalysis( m_VSPSingleAnalysis );
                Print( "COMPLETE" );

                // Get & Display Results
                PrintResults( rid );
                WriteResultsCSVFile( rid, fname_csv );
                
                // Get Result ID Vec (History and Load ResultIDs)
                array<string> rid_vec = GetStringResults( rid, "ResultsVec" );
                if ( rid_vec.length() > 0 )
                {
                    // Get History Results (rid_vec[0]) from Final Wake Iteration in History Result
                    array<double> cl_vec = GetDoubleResults( rid_vec[0], "CL" );
                    double Cl_res = cl_vec[int(cl_vec.length()) - 1];
                    double Cl_alpha_vsp = Cl_res; // alpha = 1.0 (deg)
                    Cl_alpha_vsp = Cl_res*(180/pi); // deg -> rad 
                    
                    Cl_alpha_tan_sweep[s][m] = Cl_alpha_vsp * tan( Deg2Rad(m_Sweep[s]) );
                    M_sweep_fun[s][m] = sqrt( pow( m_SuperMachVec[m], 2.0 ) - 1 ) / tan( Deg2Rad(m_Sweep[s]) );
                }

                ClearVSPModel();
            }
        }
        
        // Experimental data from Aerodynamics Of Wings And Bodies [Ashley & Landahl, pg. 169] using Plot Digitizer
        array<double> m_exp(21), Cl_alpha_tan_sweep_exp(21);
        m_exp[0] = 0.192469;
        m_exp[1] = 0.312413;
        m_exp[2] = 0.253835;
        m_exp[3] = 0.298466;
        m_exp[4] = 0.354254;
        m_exp[5] = 0.538354;
        m_exp[6] = 0.496513;
        m_exp[7] = 0.415621;
        m_exp[8] = 0.468619;
        m_exp[9] = 0.64993;
        m_exp[10] = 0.714086;
        m_exp[11] = 0.725244;
        m_exp[12] = 0.803347;
        m_exp[13] = 0.88424;
        m_exp[14] = 0.956764;
        m_exp[15] = 1.0265;
        m_exp[16] = 1.07392;
        m_exp[17] = 1.18271;
        m_exp[18] = 1.38633;
        m_exp[19] = 1.43654;
        m_exp[20] = 1.91632;
        
        Cl_alpha_tan_sweep_exp[0] = 5.81731;
        Cl_alpha_tan_sweep_exp[1] = 6.45192;
        Cl_alpha_tan_sweep_exp[2] = 5.71635;
        Cl_alpha_tan_sweep_exp[3] = 5.64423;
        Cl_alpha_tan_sweep_exp[4] = 5.47115;
        Cl_alpha_tan_sweep_exp[5] = 5.65865;
        Cl_alpha_tan_sweep_exp[6] = 5.45673;
        Cl_alpha_tan_sweep_exp[7] = 5.25481;
        Cl_alpha_tan_sweep_exp[8] = 5.06731;
        Cl_alpha_tan_sweep_exp[9] = 5.02404;
        Cl_alpha_tan_sweep_exp[10] = 4.99519;
        Cl_alpha_tan_sweep_exp[11] = 4.57692;
        Cl_alpha_tan_sweep_exp[12] = 4.17308;
        Cl_alpha_tan_sweep_exp[13] = 4.38942;
        Cl_alpha_tan_sweep_exp[14] = 3.71154;
        Cl_alpha_tan_sweep_exp[15] = 3.61058;
        Cl_alpha_tan_sweep_exp[16] = 3.35096;
        Cl_alpha_tan_sweep_exp[17] = 3.13462;
        Cl_alpha_tan_sweep_exp[18] = 2.37019;
        Cl_alpha_tan_sweep_exp[19] = 2.61538;
        Cl_alpha_tan_sweep_exp[20] = 2.02404;

        // Supersonic Delta Wing Plot: Cl_alpha*tan(sweep) = f(((M^2 - 1)^0.5)/tan(sweep)) 
        HTMLChart c1 = HTMLChart(); // Initialize Chart
        c1.m_ChartName = string("SuperDelta");
        c1.m_Legend = string("'((M^2 - 1)^0.5)/tan(sweep)','VSPAERO 35° Sweep','VSPAERO 65° Sweep','Experimental Data'");
        c1.m_Title = string("Supersonic Delta Wing: Cl_alpha*tan(sweep) = f(m)");
        c1.m_Series = string("{ 2: { pointSize: 3, color: 'gray', lineWidth: 0 } }");
        c1.m_HAxisString = string("hAxis: { title: 'm', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        c1.m_VAxisString = string("vAxis: { title: 'Cl_alpha*tan(sweep)', titleTextStyle: { bold: true }, viewWindow: { min: 0.0 } }");
        
        array<string> data_str_vec1;
        for( uint i = 0; i < num_mach; i++ )
        {
            string row = string("\t\t  [") + double( M_sweep_fun[0][i] ) + string(",") + double( Cl_alpha_tan_sweep[0][i] ) + string(",null,null],\n");
            
            data_str_vec1.push_back( row );
        }

        for( uint i = 0; i < num_mach; i++ )
        {
            string row = string("\t\t  [") + double( M_sweep_fun[1][i] ) + string(",null,") + double( Cl_alpha_tan_sweep[1][i] ) + string(",null],\n");
            
            data_str_vec1.push_back( row );
        }
        
        for( uint i = 0; i < uint(m_exp.length()); i++ )
        {
            string row = string("\t\t  [") + double( m_exp[i] ) + string(",null,null,") + double( Cl_alpha_tan_sweep_exp[i] );
            
            if ( i == uint(m_exp.length()) - 1 )
            {
                row += string("]\n");
            }
            else
            {
                row += string("],\n");
            }
            
            data_str_vec1.push_back( row );
        }
        
        c1.WriteChartHead( data_str_vec1 );
        m_SuperDeltaIDVec.push_back( c1.m_ChartName );
    }
    
    array<int> m_Sweep(2);
    private array<double> m_SuperMachVec(8);
    
    array<string> m_SuperDeltaIDVec;
}
